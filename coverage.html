
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>domain: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Notifuse/notifuse/internal/domain/contact.go (85.4%)</option>
				
				<option value="file1">github.com/Notifuse/notifuse/internal/domain/contact_list.go (100.0%)</option>
				
				<option value="file2">github.com/Notifuse/notifuse/internal/domain/list.go (100.0%)</option>
				
				<option value="file3">github.com/Notifuse/notifuse/internal/domain/mocks/mock_auth_repository.go (0.0%)</option>
				
				<option value="file4">github.com/Notifuse/notifuse/internal/domain/mocks/mock_auth_service.go (0.0%)</option>
				
				<option value="file5">github.com/Notifuse/notifuse/internal/domain/mocks/mock_contact_list_service.go (0.0%)</option>
				
				<option value="file6">github.com/Notifuse/notifuse/internal/domain/mocks/mock_contact_repository.go (0.0%)</option>
				
				<option value="file7">github.com/Notifuse/notifuse/internal/domain/mocks/mock_contact_service.go (0.0%)</option>
				
				<option value="file8">github.com/Notifuse/notifuse/internal/domain/mocks/mock_list_repository.go (0.0%)</option>
				
				<option value="file9">github.com/Notifuse/notifuse/internal/domain/mocks/mock_list_service.go (0.0%)</option>
				
				<option value="file10">github.com/Notifuse/notifuse/internal/domain/mocks/mock_user_service.go (0.0%)</option>
				
				<option value="file11">github.com/Notifuse/notifuse/internal/domain/mocks/mock_workspace_repository.go (0.0%)</option>
				
				<option value="file12">github.com/Notifuse/notifuse/internal/domain/mocks/mock_workspace_service.go (0.0%)</option>
				
				<option value="file13">github.com/Notifuse/notifuse/internal/domain/nullable_json.go (95.2%)</option>
				
				<option value="file14">github.com/Notifuse/notifuse/internal/domain/nullables.go (81.9%)</option>
				
				<option value="file15">github.com/Notifuse/notifuse/internal/domain/timezones.go (100.0%)</option>
				
				<option value="file16">github.com/Notifuse/notifuse/internal/domain/user.go (100.0%)</option>
				
				<option value="file17">github.com/Notifuse/notifuse/internal/domain/workspace.go (94.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package domain

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "net/mail"
        "net/url"
        "strconv"
        "time"

        "github.com/asaskevich/govalidator"
        "github.com/tidwall/gjson"
)

//go:generate mockgen -destination mocks/mock_contact_service.go -package mocks github.com/Notifuse/notifuse/internal/domain ContactService
//go:generate mockgen -destination mocks/mock_contact_repository.go -package mocks github.com/Notifuse/notifuse/internal/domain ContactRepository

// Contact represents a contact in the system
type Contact struct {
        // Required fields
        Email string `json:"email" valid:"required,email"`

        // Optional fields
        ExternalID   *NullableString `json:"external_id,omitempty" valid:"optional"`
        Timezone     *NullableString `json:"timezone,omitempty" valid:"optional,timezone"`
        Language     *NullableString `json:"language,omitempty" valid:"optional"`
        FirstName    *NullableString `json:"first_name,omitempty" valid:"optional"`
        LastName     *NullableString `json:"last_name,omitempty" valid:"optional"`
        Phone        *NullableString `json:"phone,omitempty" valid:"optional"`
        AddressLine1 *NullableString `json:"address_line_1,omitempty" valid:"optional"`
        AddressLine2 *NullableString `json:"address_line_2,omitempty" valid:"optional"`
        Country      *NullableString `json:"country,omitempty" valid:"optional"`
        Postcode     *NullableString `json:"postcode,omitempty" valid:"optional"`
        State        *NullableString `json:"state,omitempty" valid:"optional"`
        JobTitle     *NullableString `json:"job_title,omitempty" valid:"optional"`

        // Commerce related fields
        LifetimeValue *NullableFloat64 `json:"lifetime_value,omitempty" valid:"optional"`
        OrdersCount   *NullableFloat64 `json:"orders_count,omitempty" valid:"optional"`
        LastOrderAt   *NullableTime    `json:"last_order_at,omitempty" valid:"optional"`

        // Custom fields
        CustomString1 *NullableString `json:"custom_string_1,omitempty" valid:"optional"`
        CustomString2 *NullableString `json:"custom_string_2,omitempty" valid:"optional"`
        CustomString3 *NullableString `json:"custom_string_3,omitempty" valid:"optional"`
        CustomString4 *NullableString `json:"custom_string_4,omitempty" valid:"optional"`
        CustomString5 *NullableString `json:"custom_string_5,omitempty" valid:"optional"`

        CustomNumber1 *NullableFloat64 `json:"custom_number_1,omitempty" valid:"optional"`
        CustomNumber2 *NullableFloat64 `json:"custom_number_2,omitempty" valid:"optional"`
        CustomNumber3 *NullableFloat64 `json:"custom_number_3,omitempty" valid:"optional"`
        CustomNumber4 *NullableFloat64 `json:"custom_number_4,omitempty" valid:"optional"`
        CustomNumber5 *NullableFloat64 `json:"custom_number_5,omitempty" valid:"optional"`

        CustomDatetime1 *NullableTime `json:"custom_datetime_1,omitempty" valid:"optional"`
        CustomDatetime2 *NullableTime `json:"custom_datetime_2,omitempty" valid:"optional"`
        CustomDatetime3 *NullableTime `json:"custom_datetime_3,omitempty" valid:"optional"`
        CustomDatetime4 *NullableTime `json:"custom_datetime_4,omitempty" valid:"optional"`
        CustomDatetime5 *NullableTime `json:"custom_datetime_5,omitempty" valid:"optional"`

        CustomJSON1 *NullableJSON `json:"custom_json_1,omitempty" valid:"optional"`
        CustomJSON2 *NullableJSON `json:"custom_json_2,omitempty" valid:"optional"`
        CustomJSON3 *NullableJSON `json:"custom_json_3,omitempty" valid:"optional"`
        CustomJSON4 *NullableJSON `json:"custom_json_4,omitempty" valid:"optional"`
        CustomJSON5 *NullableJSON `json:"custom_json_5,omitempty" valid:"optional"`

        // Timestamps
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// isValidEmail checks if the email is valid
func isValidEmail(email string) bool <span class="cov8" title="1">{
        if _, err := mail.ParseAddress(email); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Validate ensures that the contact has all required fields
func (c *Contact) Validate() error <span class="cov8" title="1">{
        // Email is required
        if c.Email == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("email is required")
        }</span>
        // Email must be valid
        <span class="cov8" title="1">if !isValidEmail(c.Email) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid email format")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// For database scanning
type dbContact struct {
        Email      string
        ExternalID sql.NullString
        Timezone   sql.NullString
        Language   sql.NullString

        FirstName    sql.NullString
        LastName     sql.NullString
        Phone        sql.NullString
        AddressLine1 sql.NullString
        AddressLine2 sql.NullString
        Country      sql.NullString
        Postcode     sql.NullString
        State        sql.NullString
        JobTitle     sql.NullString

        LifetimeValue sql.NullFloat64
        OrdersCount   sql.NullFloat64
        LastOrderAt   sql.NullTime

        CustomString1 sql.NullString
        CustomString2 sql.NullString
        CustomString3 sql.NullString
        CustomString4 sql.NullString
        CustomString5 sql.NullString

        CustomNumber1 sql.NullFloat64
        CustomNumber2 sql.NullFloat64
        CustomNumber3 sql.NullFloat64
        CustomNumber4 sql.NullFloat64
        CustomNumber5 sql.NullFloat64

        CustomDatetime1 sql.NullTime
        CustomDatetime2 sql.NullTime
        CustomDatetime3 sql.NullTime
        CustomDatetime4 sql.NullTime
        CustomDatetime5 sql.NullTime

        CustomJSON1 []byte
        CustomJSON2 []byte
        CustomJSON3 []byte
        CustomJSON4 []byte
        CustomJSON5 []byte

        CreatedAt time.Time
        UpdatedAt time.Time
}

// ScanContact scans a contact from the database
func ScanContact(scanner interface {
        Scan(dest ...interface{}) error
}) (*Contact, error) <span class="cov8" title="1">{
        var dbc dbContact
        if err := scanner.Scan(
                &amp;dbc.Email,
                &amp;dbc.ExternalID,
                &amp;dbc.Timezone,
                &amp;dbc.Language,
                &amp;dbc.FirstName,
                &amp;dbc.LastName,
                &amp;dbc.Phone,
                &amp;dbc.AddressLine1,
                &amp;dbc.AddressLine2,
                &amp;dbc.Country,
                &amp;dbc.Postcode,
                &amp;dbc.State,
                &amp;dbc.JobTitle,
                &amp;dbc.LifetimeValue,
                &amp;dbc.OrdersCount,
                &amp;dbc.LastOrderAt,
                &amp;dbc.CustomString1,
                &amp;dbc.CustomString2,
                &amp;dbc.CustomString3,
                &amp;dbc.CustomString4,
                &amp;dbc.CustomString5,
                &amp;dbc.CustomNumber1,
                &amp;dbc.CustomNumber2,
                &amp;dbc.CustomNumber3,
                &amp;dbc.CustomNumber4,
                &amp;dbc.CustomNumber5,
                &amp;dbc.CustomDatetime1,
                &amp;dbc.CustomDatetime2,
                &amp;dbc.CustomDatetime3,
                &amp;dbc.CustomDatetime4,
                &amp;dbc.CustomDatetime5,
                &amp;dbc.CustomJSON1,
                &amp;dbc.CustomJSON2,
                &amp;dbc.CustomJSON3,
                &amp;dbc.CustomJSON4,
                &amp;dbc.CustomJSON5,
                &amp;dbc.CreatedAt,
                &amp;dbc.UpdatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c := &amp;Contact{
                Email:      dbc.Email,
                ExternalID: &amp;NullableString{String: dbc.ExternalID.String, IsNull: !dbc.ExternalID.Valid},
                Timezone:   &amp;NullableString{String: dbc.Timezone.String, IsNull: !dbc.Timezone.Valid},
                Language:   &amp;NullableString{String: dbc.Language.String, IsNull: !dbc.Language.Valid},

                FirstName: &amp;NullableString{
                        String: dbc.FirstName.String,
                        IsNull: !dbc.FirstName.Valid,
                },
                LastName: &amp;NullableString{
                        String: dbc.LastName.String,
                        IsNull: !dbc.LastName.Valid,
                },
                Phone: &amp;NullableString{
                        String: dbc.Phone.String,
                        IsNull: !dbc.Phone.Valid,
                },
                AddressLine1: &amp;NullableString{
                        String: dbc.AddressLine1.String,
                        IsNull: !dbc.AddressLine1.Valid,
                },
                AddressLine2: &amp;NullableString{
                        String: dbc.AddressLine2.String,
                        IsNull: !dbc.AddressLine2.Valid,
                },
                Country: &amp;NullableString{
                        String: dbc.Country.String,
                        IsNull: !dbc.Country.Valid,
                },
                Postcode: &amp;NullableString{
                        String: dbc.Postcode.String,
                        IsNull: !dbc.Postcode.Valid,
                },
                State: &amp;NullableString{
                        String: dbc.State.String,
                        IsNull: !dbc.State.Valid,
                },
                JobTitle: &amp;NullableString{
                        String: dbc.JobTitle.String,
                        IsNull: !dbc.JobTitle.Valid,
                },

                LifetimeValue: &amp;NullableFloat64{
                        Float64: dbc.LifetimeValue.Float64,
                        IsNull:  !dbc.LifetimeValue.Valid,
                },
                OrdersCount: &amp;NullableFloat64{
                        Float64: dbc.OrdersCount.Float64,
                        IsNull:  !dbc.OrdersCount.Valid,
                },
                LastOrderAt: &amp;NullableTime{
                        Time:   dbc.LastOrderAt.Time,
                        IsNull: !dbc.LastOrderAt.Valid,
                },

                CustomString1: &amp;NullableString{
                        String: dbc.CustomString1.String,
                        IsNull: !dbc.CustomString1.Valid,
                },
                CustomString2: &amp;NullableString{
                        String: dbc.CustomString2.String,
                        IsNull: !dbc.CustomString2.Valid,
                },
                CustomString3: &amp;NullableString{
                        String: dbc.CustomString3.String,
                        IsNull: !dbc.CustomString3.Valid,
                },
                CustomString4: &amp;NullableString{
                        String: dbc.CustomString4.String,
                        IsNull: !dbc.CustomString4.Valid,
                },
                CustomString5: &amp;NullableString{
                        String: dbc.CustomString5.String,
                        IsNull: !dbc.CustomString5.Valid,
                },

                CustomNumber1: &amp;NullableFloat64{
                        Float64: dbc.CustomNumber1.Float64,
                        IsNull:  !dbc.CustomNumber1.Valid,
                },
                CustomNumber2: &amp;NullableFloat64{
                        Float64: dbc.CustomNumber2.Float64,
                        IsNull:  !dbc.CustomNumber2.Valid,
                },
                CustomNumber3: &amp;NullableFloat64{
                        Float64: dbc.CustomNumber3.Float64,
                        IsNull:  !dbc.CustomNumber3.Valid,
                },
                CustomNumber4: &amp;NullableFloat64{
                        Float64: dbc.CustomNumber4.Float64,
                        IsNull:  !dbc.CustomNumber4.Valid,
                },
                CustomNumber5: &amp;NullableFloat64{
                        Float64: dbc.CustomNumber5.Float64,
                        IsNull:  !dbc.CustomNumber5.Valid,
                },

                CustomDatetime1: &amp;NullableTime{
                        Time:   dbc.CustomDatetime1.Time,
                        IsNull: !dbc.CustomDatetime1.Valid,
                },
                CustomDatetime2: &amp;NullableTime{
                        Time:   dbc.CustomDatetime2.Time,
                        IsNull: !dbc.CustomDatetime2.Valid,
                },
                CustomDatetime3: &amp;NullableTime{
                        Time:   dbc.CustomDatetime3.Time,
                        IsNull: !dbc.CustomDatetime3.Valid,
                },
                CustomDatetime4: &amp;NullableTime{
                        Time:   dbc.CustomDatetime4.Time,
                        IsNull: !dbc.CustomDatetime4.Valid,
                },
                CustomDatetime5: &amp;NullableTime{
                        Time:   dbc.CustomDatetime5.Time,
                        IsNull: !dbc.CustomDatetime5.Valid,
                },

                // Initialize CustomJSON fields with IsNull=true by default
                CustomJSON1: &amp;NullableJSON{IsNull: true},
                CustomJSON2: &amp;NullableJSON{IsNull: true},
                CustomJSON3: &amp;NullableJSON{IsNull: true},
                CustomJSON4: &amp;NullableJSON{IsNull: true},
                CustomJSON5: &amp;NullableJSON{IsNull: true},

                CreatedAt: dbc.CreatedAt,
                UpdatedAt: dbc.UpdatedAt,
        }

        // Handle custom JSON fields
        if len(dbc.CustomJSON1) &gt; 0 &amp;&amp; string(dbc.CustomJSON1) != "null" </span><span class="cov8" title="1">{
                var data interface{}
                if err := json.Unmarshal(dbc.CustomJSON1, &amp;data); err == nil </span><span class="cov8" title="1">{
                        c.CustomJSON1 = &amp;NullableJSON{Data: data, IsNull: false}
                }</span>
        }
        <span class="cov8" title="1">if len(dbc.CustomJSON2) &gt; 0 &amp;&amp; string(dbc.CustomJSON2) != "null" </span><span class="cov8" title="1">{
                var data interface{}
                if err := json.Unmarshal(dbc.CustomJSON2, &amp;data); err == nil </span><span class="cov8" title="1">{
                        c.CustomJSON2 = &amp;NullableJSON{Data: data, IsNull: false}
                }</span>
        }
        <span class="cov8" title="1">if len(dbc.CustomJSON3) &gt; 0 &amp;&amp; string(dbc.CustomJSON3) != "null" </span><span class="cov8" title="1">{
                var data interface{}
                if err := json.Unmarshal(dbc.CustomJSON3, &amp;data); err == nil </span><span class="cov8" title="1">{
                        c.CustomJSON3 = &amp;NullableJSON{Data: data, IsNull: false}
                }</span>
        }
        <span class="cov8" title="1">if len(dbc.CustomJSON4) &gt; 0 &amp;&amp; string(dbc.CustomJSON4) != "null" </span><span class="cov8" title="1">{
                var data interface{}
                if err := json.Unmarshal(dbc.CustomJSON4, &amp;data); err == nil </span><span class="cov8" title="1">{
                        c.CustomJSON4 = &amp;NullableJSON{Data: data, IsNull: false}
                }</span>
        }
        <span class="cov8" title="1">if len(dbc.CustomJSON5) &gt; 0 &amp;&amp; string(dbc.CustomJSON5) != "null" </span><span class="cov8" title="1">{
                var data interface{}
                if err := json.Unmarshal(dbc.CustomJSON5, &amp;data); err == nil </span><span class="cov8" title="1">{
                        c.CustomJSON5 = &amp;NullableJSON{Data: data, IsNull: false}
                }</span>
        }

        <span class="cov8" title="1">return c, nil</span>
}

// GetContactsRequest represents a request to get contacts with filters and pagination
type GetContactsRequest struct {
        // Required fields
        WorkspaceID string `json:"workspace_id" valid:"required,alphanum,stringlength(1|20)"`

        // Optional filters
        Email      string `json:"email,omitempty" valid:"optional,email"`
        ExternalID string `json:"external_id,omitempty" valid:"optional"`
        FirstName  string `json:"first_name,omitempty" valid:"optional"`
        LastName   string `json:"last_name,omitempty" valid:"optional"`
        Phone      string `json:"phone,omitempty" valid:"optional"`
        Country    string `json:"country,omitempty" valid:"optional"`

        // Pagination
        Limit  int    `json:"limit,omitempty" valid:"optional,range(1|100)"`
        Cursor string `json:"cursor,omitempty" valid:"optional"`
}

func (r *GetContactsRequest) FromQueryParams(queryParams url.Values) (err error) <span class="cov8" title="1">{
        r.WorkspaceID = queryParams.Get("workspace_id")
        r.Email = queryParams.Get("email")
        r.ExternalID = queryParams.Get("external_id")
        r.FirstName = queryParams.Get("first_name")
        r.LastName = queryParams.Get("last_name")
        r.Phone = queryParams.Get("phone")
        r.Country = queryParams.Get("country")

        // handle limit and cursor
        r.Limit, err = strconv.Atoi(queryParams.Get("limit"))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid limit: %w", err)
        }</span>
        <span class="cov8" title="1">r.Cursor = queryParams.Get("cursor")

        // Validate the request
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid request: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetContactsResponse represents the response from getting contacts
type GetContactsResponse struct {
        Contacts   []*Contact `json:"contacts"`
        NextCursor string     `json:"next_cursor,omitempty"`
}

// Validate ensures that the request has all required fields and valid values
func (r *GetContactsRequest) Validate() error <span class="cov8" title="1">{
        if r.WorkspaceID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("workspace_id is required")
        }</span>

        // Set default limit if not provided
        <span class="cov8" title="1">if r.Limit == 0 </span><span class="cov8" title="1">{
                r.Limit = 20
        }</span>

        // Enforce maximum limit
        <span class="cov8" title="1">if r.Limit &gt; 100 </span><span class="cov8" title="1">{
                r.Limit = 100
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Request/Response types
type GetContactByEmailRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        Email       string `json:"email" valid:"required,email"`
}

type GetContactByExternalIDRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        ExternalID  string `json:"external_id" valid:"required"`
}

type DeleteContactRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        Email       string `json:"email" valid:"required,email"`
}

func (r *DeleteContactRequest) Validate() error <span class="cov8" title="1">{
        if r.WorkspaceID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("workspace_id is required")
        }</span>
        <span class="cov8" title="1">if r.Email == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("email is required")
        }</span>
        <span class="cov8" title="1">if !govalidator.IsEmail(r.Email) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid email format")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Add the request type for batch importing contacts
type BatchImportContactsRequest struct {
        WorkspaceID string          `json:"workspace_id" valid:"required"`
        Contacts    json.RawMessage `json:"contacts" valid:"required"`
}

func (r *BatchImportContactsRequest) Validate() (contacts []*Contact, workspaceID string, err error) <span class="cov8" title="1">{
        if r.WorkspaceID == "" </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("workspace_id is required")
        }</span>

        // Parse the raw JSON bytes directly as an array
        <span class="cov8" title="1">jsonResult := gjson.ParseBytes(r.Contacts)
        if !jsonResult.IsArray() </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("contacts must be an array")
        }</span>

        <span class="cov8" title="1">contactsArray := jsonResult.Array()
        if len(contactsArray) == 0 </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("contacts array is empty")
        }</span>

        // Parse each contact
        <span class="cov8" title="1">contacts = make([]*Contact, 0, len(contactsArray))
        for i, contactJson := range contactsArray </span><span class="cov8" title="1">{
                contact, err := FromJSON(contactJson)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, "", fmt.Errorf("invalid contact at index %d: %w", i, err)
                }</span>
                <span class="cov8" title="1">contacts = append(contacts, contact)</span>
        }
        <span class="cov8" title="1">return contacts, r.WorkspaceID, nil</span>
}

type UpsertContactRequest struct {
        WorkspaceID string          `json:"workspace_id" valid:"required"`
        Contact     json.RawMessage `json:"contact" valid:"required"`
}

func (r *UpsertContactRequest) Validate() (contact *Contact, workspaceID string, err error) <span class="cov8" title="1">{
        if r.WorkspaceID == "" </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("workspace_id is required")
        }</span>
        <span class="cov8" title="1">jsonResult := gjson.ParseBytes(r.Contact)
        if !jsonResult.Exists() </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("contact field is required")
        }</span>
        <span class="cov8" title="1">contact, err = FromJSON(jsonResult)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("invalid contact: %w", err)
        }</span>
        <span class="cov8" title="1">return contact, r.WorkspaceID, nil</span>
}

// ContactService provides operations for managing contacts
type ContactService interface {
        // GetContactByEmail retrieves a contact by email
        GetContactByEmail(ctx context.Context, workspaceID string, email string) (*Contact, error)

        // GetContactByExternalID retrieves a contact by external ID
        GetContactByExternalID(ctx context.Context, workspaceID string, externalID string) (*Contact, error)

        // GetContacts retrieves contacts with filters and pagination
        GetContacts(ctx context.Context, req *GetContactsRequest) (*GetContactsResponse, error)

        // DeleteContact deletes a contact by email
        DeleteContact(ctx context.Context, workspaceID string, email string) error

        // BatchImportContacts imports a batch of contacts (create or update)
        BatchImportContacts(ctx context.Context, workspaceID string, contacts []*Contact) error

        // UpsertContact creates a new contact or updates an existing one
        // Returns a boolean indicating whether a new contact was created (true) or an existing one was updated (false)
        UpsertContact(ctx context.Context, workspaceID string, contact *Contact) (bool, error)
}

type ContactRepository interface {
        // GetContactByEmail retrieves a contact by its email
        GetContactByEmail(ctx context.Context, workspaceID string, email string) (*Contact, error)

        // GetContactByExternalID retrieves a contact by its external ID
        GetContactByExternalID(ctx context.Context, workspaceID string, externalID string) (*Contact, error)

        // GetContacts retrieves contacts with filters and pagination
        GetContacts(ctx context.Context, req *GetContactsRequest) (*GetContactsResponse, error)

        // DeleteContact deletes a contact
        DeleteContact(ctx context.Context, workspaceID string, email string) error

        // BatchImportContacts inserts or updates multiple contacts in a batch operation
        BatchImportContacts(ctx context.Context, workspaceID string, contacts []*Contact) error

        // UpsertContact creates a new contact or updates an existing one
        UpsertContact(ctx context.Context, workspaceID string, contact *Contact) (bool, error)
}

// ErrContactNotFound is returned when a contact is not found
type ErrContactNotFound struct {
        Message string
}

func (e *ErrContactNotFound) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// FromJSON parses JSON data into a Contact struct
// The JSON data can be provided as a []byte or as a gjson.Result
func FromJSON(data interface{}) (*Contact, error) <span class="cov8" title="1">{
        var jsonResult gjson.Result

        switch v := data.(type) </span>{
        case []byte:<span class="cov8" title="1">
                jsonResult = gjson.ParseBytes(v)</span>
        case gjson.Result:<span class="cov8" title="1">
                jsonResult = v</span>
        case string:<span class="cov8" title="1">
                jsonResult = gjson.Parse(v)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported data type: %T", data)</span>
        }

        // Extract required fields
        <span class="cov8" title="1">email := jsonResult.Get("email").String()
        if email == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("email is required")
        }</span>

        // Validate email format
        <span class="cov8" title="1">if !isValidEmail(email) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid email format")
        }</span>

        // Create the contact with required fields
        <span class="cov8" title="1">contact := &amp;Contact{
                Email: email,
        }

        // Parse nullable string fields
        if err := parseNullableString(jsonResult, "external_id", &amp;contact.ExternalID); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "timezone", &amp;contact.Timezone); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "language", &amp;contact.Language); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "first_name", &amp;contact.FirstName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "last_name", &amp;contact.LastName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "phone", &amp;contact.Phone); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "address_line_1", &amp;contact.AddressLine1); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "address_line_2", &amp;contact.AddressLine2); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "country", &amp;contact.Country); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "postcode", &amp;contact.Postcode); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "state", &amp;contact.State); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "job_title", &amp;contact.JobTitle); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse custom string fields
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "custom_string_1", &amp;contact.CustomString1); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "custom_string_2", &amp;contact.CustomString2); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "custom_string_3", &amp;contact.CustomString3); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "custom_string_4", &amp;contact.CustomString4); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableString(jsonResult, "custom_string_5", &amp;contact.CustomString5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse nullable number fields
        <span class="cov8" title="1">if err := parseNullableFloat(jsonResult, "lifetime_value", &amp;contact.LifetimeValue); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableFloat(jsonResult, "orders_count", &amp;contact.OrdersCount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse custom number fields
        <span class="cov8" title="1">if err := parseNullableFloat(jsonResult, "custom_number_1", &amp;contact.CustomNumber1); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableFloat(jsonResult, "custom_number_2", &amp;contact.CustomNumber2); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableFloat(jsonResult, "custom_number_3", &amp;contact.CustomNumber3); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableFloat(jsonResult, "custom_number_4", &amp;contact.CustomNumber4); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableFloat(jsonResult, "custom_number_5", &amp;contact.CustomNumber5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse date fields
        <span class="cov8" title="1">if err := parseNullableTime(jsonResult, "last_order_at", &amp;contact.LastOrderAt); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Parse custom datetime fields
        <span class="cov8" title="1">if err := parseNullableTime(jsonResult, "custom_datetime_1", &amp;contact.CustomDatetime1); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableTime(jsonResult, "custom_datetime_2", &amp;contact.CustomDatetime2); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableTime(jsonResult, "custom_datetime_3", &amp;contact.CustomDatetime3); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableTime(jsonResult, "custom_datetime_4", &amp;contact.CustomDatetime4); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := parseNullableTime(jsonResult, "custom_datetime_5", &amp;contact.CustomDatetime5); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse custom JSON fields if they exist
        <span class="cov8" title="1">for i := 1; i &lt;= 5; i++ </span><span class="cov8" title="1">{
                field := fmt.Sprintf("custom_json_%d", i)
                if value := jsonResult.Get(field); value.Exists() </span><span class="cov8" title="1">{
                        // Check if the value is explicitly null
                        if value.Type == gjson.Null </span><span class="cov8" title="1">{
                                // Set the field as null
                                switch i </span>{
                                case 1:<span class="cov8" title="1">
                                        contact.CustomJSON1 = &amp;NullableJSON{Data: nil, IsNull: true}</span>
                                case 2:<span class="cov8" title="1">
                                        contact.CustomJSON2 = &amp;NullableJSON{Data: nil, IsNull: true}</span>
                                case 3:<span class="cov8" title="1">
                                        contact.CustomJSON3 = &amp;NullableJSON{Data: nil, IsNull: true}</span>
                                case 4:<span class="cov8" title="1">
                                        contact.CustomJSON4 = &amp;NullableJSON{Data: nil, IsNull: true}</span>
                                case 5:<span class="cov8" title="1">
                                        contact.CustomJSON5 = &amp;NullableJSON{Data: nil, IsNull: true}</span>
                                }
                                <span class="cov8" title="1">continue</span>
                        }

                        // make sure the value is a valid JSON object or array
                        <span class="cov8" title="1">if !value.IsObject() &amp;&amp; !value.IsArray() </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("invalid JSON value for custom_json_%d, got %s", i, value.Type)
                        }</span>

                        // Set the custom JSON field
                        <span class="cov8" title="1">switch i </span>{
                        case 1:<span class="cov8" title="1">
                                contact.CustomJSON1 = &amp;NullableJSON{Data: value.Value(), IsNull: false}</span>
                        case 2:<span class="cov8" title="1">
                                contact.CustomJSON2 = &amp;NullableJSON{Data: value.Value(), IsNull: false}</span>
                        case 3:<span class="cov0" title="0">
                                contact.CustomJSON3 = &amp;NullableJSON{Data: value.Value(), IsNull: false}</span>
                        case 4:<span class="cov0" title="0">
                                contact.CustomJSON4 = &amp;NullableJSON{Data: value.Value(), IsNull: false}</span>
                        case 5:<span class="cov0" title="0">
                                contact.CustomJSON5 = &amp;NullableJSON{Data: value.Value(), IsNull: false}</span>
                        }
                }
        }

        <span class="cov8" title="1">return contact, nil</span>
}

// Helper functions for parsing nullable fields from JSON
func parseNullableString(result gjson.Result, field string, target **NullableString) error <span class="cov8" title="1">{
        if value := result.Get(field); value.Exists() </span><span class="cov8" title="1">{
                if value.Type == gjson.Null </span><span class="cov8" title="1">{
                        *target = &amp;NullableString{IsNull: true}
                }</span> else<span class="cov8" title="1"> if value.Type == gjson.String </span><span class="cov8" title="1">{
                        *target = &amp;NullableString{String: value.String(), IsNull: false}
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("invalid type for %s: expected string, got %s", field, value.Type)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func parseNullableFloat(result gjson.Result, field string, target **NullableFloat64) error <span class="cov8" title="1">{
        if value := result.Get(field); value.Exists() </span><span class="cov8" title="1">{
                if value.Type == gjson.Null </span><span class="cov8" title="1">{
                        *target = &amp;NullableFloat64{IsNull: true}
                }</span> else<span class="cov8" title="1"> if value.Type == gjson.Number </span><span class="cov8" title="1">{
                        *target = &amp;NullableFloat64{Float64: value.Float(), IsNull: false}
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("invalid type for %s: expected number, got %s", field, value.Type)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func parseNullableTime(result gjson.Result, field string, target **NullableTime) error <span class="cov8" title="1">{
        if value := result.Get(field); value.Exists() </span><span class="cov8" title="1">{
                if value.Type == gjson.Null </span><span class="cov8" title="1">{
                        *target = &amp;NullableTime{IsNull: true}
                }</span> else<span class="cov8" title="1"> if value.Type == gjson.String </span><span class="cov8" title="1">{
                        t, err := time.Parse(time.RFC3339, value.String())
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid time format for %s: %v", field, err)
                        }</span>
                        <span class="cov8" title="1">*target = &amp;NullableTime{Time: t, IsNull: false}</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid type for %s: expected string, got %s", field, value.Type)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Merge updates non-nil fields from another contact
func (c *Contact) Merge(other *Contact) <span class="cov8" title="1">{
        if other == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Required fields
        <span class="cov8" title="1">if other.Email != "" </span><span class="cov8" title="1">{
                c.Email = other.Email
        }</span>

        // Optional fields
        <span class="cov8" title="1">if other.ExternalID != nil </span><span class="cov0" title="0">{
                c.ExternalID = other.ExternalID
        }</span>
        <span class="cov8" title="1">if other.Timezone != nil </span><span class="cov0" title="0">{
                c.Timezone = other.Timezone
        }</span>
        <span class="cov8" title="1">if other.Language != nil </span><span class="cov0" title="0">{
                c.Language = other.Language
        }</span>
        <span class="cov8" title="1">if other.FirstName != nil </span><span class="cov8" title="1">{
                c.FirstName = other.FirstName
        }</span>
        <span class="cov8" title="1">if other.LastName != nil </span><span class="cov0" title="0">{
                c.LastName = other.LastName
        }</span>
        <span class="cov8" title="1">if other.Phone != nil </span><span class="cov0" title="0">{
                c.Phone = other.Phone
        }</span>
        <span class="cov8" title="1">if other.AddressLine1 != nil </span><span class="cov8" title="1">{
                c.AddressLine1 = other.AddressLine1
        }</span>
        <span class="cov8" title="1">if other.AddressLine2 != nil </span><span class="cov0" title="0">{
                c.AddressLine2 = other.AddressLine2
        }</span>
        <span class="cov8" title="1">if other.Country != nil </span><span class="cov8" title="1">{
                c.Country = other.Country
        }</span>
        <span class="cov8" title="1">if other.Postcode != nil </span><span class="cov0" title="0">{
                c.Postcode = other.Postcode
        }</span>
        <span class="cov8" title="1">if other.State != nil </span><span class="cov0" title="0">{
                c.State = other.State
        }</span>
        <span class="cov8" title="1">if other.JobTitle != nil </span><span class="cov0" title="0">{
                c.JobTitle = other.JobTitle
        }</span>

        // Commerce related fields
        <span class="cov8" title="1">if other.LifetimeValue != nil </span><span class="cov8" title="1">{
                c.LifetimeValue = other.LifetimeValue
        }</span>
        <span class="cov8" title="1">if other.OrdersCount != nil </span><span class="cov8" title="1">{
                c.OrdersCount = other.OrdersCount
        }</span>
        <span class="cov8" title="1">if other.LastOrderAt != nil </span><span class="cov8" title="1">{
                c.LastOrderAt = other.LastOrderAt
        }</span>

        // Custom string fields
        <span class="cov8" title="1">if other.CustomString1 != nil </span><span class="cov8" title="1">{
                c.CustomString1 = other.CustomString1
        }</span>
        <span class="cov8" title="1">if other.CustomString2 != nil </span><span class="cov8" title="1">{
                c.CustomString2 = other.CustomString2
        }</span>
        <span class="cov8" title="1">if other.CustomString3 != nil </span><span class="cov8" title="1">{
                c.CustomString3 = other.CustomString3
        }</span>
        <span class="cov8" title="1">if other.CustomString4 != nil </span><span class="cov8" title="1">{
                c.CustomString4 = other.CustomString4
        }</span>
        <span class="cov8" title="1">if other.CustomString5 != nil </span><span class="cov8" title="1">{
                c.CustomString5 = other.CustomString5
        }</span>

        // Custom number fields
        <span class="cov8" title="1">if other.CustomNumber1 != nil </span><span class="cov8" title="1">{
                c.CustomNumber1 = other.CustomNumber1
        }</span>
        <span class="cov8" title="1">if other.CustomNumber2 != nil </span><span class="cov8" title="1">{
                c.CustomNumber2 = other.CustomNumber2
        }</span>
        <span class="cov8" title="1">if other.CustomNumber3 != nil </span><span class="cov8" title="1">{
                c.CustomNumber3 = other.CustomNumber3
        }</span>
        <span class="cov8" title="1">if other.CustomNumber4 != nil </span><span class="cov8" title="1">{
                c.CustomNumber4 = other.CustomNumber4
        }</span>
        <span class="cov8" title="1">if other.CustomNumber5 != nil </span><span class="cov8" title="1">{
                c.CustomNumber5 = other.CustomNumber5
        }</span>

        // Custom datetime fields
        <span class="cov8" title="1">if other.CustomDatetime1 != nil </span><span class="cov8" title="1">{
                c.CustomDatetime1 = other.CustomDatetime1
        }</span>
        <span class="cov8" title="1">if other.CustomDatetime2 != nil </span><span class="cov8" title="1">{
                c.CustomDatetime2 = other.CustomDatetime2
        }</span>
        <span class="cov8" title="1">if other.CustomDatetime3 != nil </span><span class="cov8" title="1">{
                c.CustomDatetime3 = other.CustomDatetime3
        }</span>
        <span class="cov8" title="1">if other.CustomDatetime4 != nil </span><span class="cov8" title="1">{
                c.CustomDatetime4 = other.CustomDatetime4
        }</span>
        <span class="cov8" title="1">if other.CustomDatetime5 != nil </span><span class="cov8" title="1">{
                c.CustomDatetime5 = other.CustomDatetime5
        }</span>

        // Custom JSON fields
        <span class="cov8" title="1">if other.CustomJSON1 != nil </span><span class="cov8" title="1">{
                c.CustomJSON1 = other.CustomJSON1
        }</span>
        <span class="cov8" title="1">if other.CustomJSON2 != nil </span><span class="cov8" title="1">{
                c.CustomJSON2 = other.CustomJSON2
        }</span>
        <span class="cov8" title="1">if other.CustomJSON3 != nil </span><span class="cov8" title="1">{
                c.CustomJSON3 = other.CustomJSON3
        }</span>
        <span class="cov8" title="1">if other.CustomJSON4 != nil </span><span class="cov8" title="1">{
                c.CustomJSON4 = other.CustomJSON4
        }</span>
        <span class="cov8" title="1">if other.CustomJSON5 != nil </span><span class="cov8" title="1">{
                c.CustomJSON5 = other.CustomJSON5
        }</span>

        // Update timestamps
        <span class="cov8" title="1">if !other.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                c.CreatedAt = other.CreatedAt
        }</span>
        <span class="cov8" title="1">if !other.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                c.UpdatedAt = other.UpdatedAt
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package domain

import (
        "context"
        "fmt"
        "net/url"
        "time"

        "github.com/asaskevich/govalidator"
)

//go:generate mockgen -destination mocks/mock_contact_list_service.go -package mocks github.com/Notifuse/notifuse/internal/domain ContactListService

// ContactListStatus represents the status of a contact's subscription to a list
type ContactListStatus string

const (
        // ContactListStatusActive indicates an active subscription
        ContactListStatusActive ContactListStatus = "active"
        // ContactListStatusPending indicates a pending subscription (e.g., waiting for double opt-in)
        ContactListStatusPending ContactListStatus = "pending"
        // ContactListStatusUnsubscribed indicates an unsubscribed status
        ContactListStatusUnsubscribed ContactListStatus = "unsubscribed"
        // ContactListStatusBounced indicates the contact's email has bounced
        ContactListStatusBounced ContactListStatus = "bounced"
        // ContactListStatusComplained indicates the contact has complained (e.g., marked as spam)
        ContactListStatusComplained ContactListStatus = "complained"
)

// ContactList represents the relationship between a contact and a list
type ContactList struct {
        Email     string            `json:"email" valid:"required,email"`
        ListID    string            `json:"list_id" valid:"required,alphanum,stringlength(1|20)"`
        Status    ContactListStatus `json:"status" valid:"required,in(active|pending|unsubscribed|bounced|complained)"`
        CreatedAt time.Time         `json:"created_at"`
        UpdatedAt time.Time         `json:"updated_at"`
}

// Validate performs validation on the contact list fields
func (cl *ContactList) Validate() error <span class="cov8" title="1">{
        // Check required fields first
        if cl.Email == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("email is required")
        }</span>
        <span class="cov8" title="1">if cl.ListID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("list_id is required")
        }</span>
        <span class="cov8" title="1">if cl.Status == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("status is required")
        }</span>

        // Then use govalidator for additional validation
        <span class="cov8" title="1">if _, err := govalidator.ValidateStruct(cl); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid contact list: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// For database scanning
type dbContactList struct {
        Email     string
        ListID    string
        Status    string
        CreatedAt time.Time
        UpdatedAt time.Time
}

// ScanContactList scans a contact list from the database
func ScanContactList(scanner interface {
        Scan(dest ...interface{}) error
}) (*ContactList, error) <span class="cov8" title="1">{
        var dbcl dbContactList
        if err := scanner.Scan(
                &amp;dbcl.Email,
                &amp;dbcl.ListID,
                &amp;dbcl.Status,
                &amp;dbcl.CreatedAt,
                &amp;dbcl.UpdatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cl := &amp;ContactList{
                Email:     dbcl.Email,
                ListID:    dbcl.ListID,
                Status:    ContactListStatus(dbcl.Status),
                CreatedAt: dbcl.CreatedAt,
                UpdatedAt: dbcl.UpdatedAt,
        }

        return cl, nil</span>
}

// Request/Response types
type AddContactToListRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        Email       string `json:"email" valid:"required,email"`
        ListID      string `json:"list_id" valid:"required"`
        Status      string `json:"status" valid:"required,in(active|pending|unsubscribed|blacklisted)"`
}

func (r *AddContactToListRequest) Validate() (contactList *ContactList, workspaceID string, err error) <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("invalid add contact to list request: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;ContactList{
                Email:  r.Email,
                ListID: r.ListID,
                Status: ContactListStatus(r.Status),
        }, r.WorkspaceID, nil</span>
}

type GetContactListRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        Email       string `json:"email" valid:"required,email"`
        ListID      string `json:"list_id" valid:"required"`
}

func (r *GetContactListRequest) FromURLParams(queryParams url.Values) (err error) <span class="cov8" title="1">{
        r.WorkspaceID = queryParams.Get("workspace_id")
        r.Email = queryParams.Get("email")
        r.ListID = queryParams.Get("list_id")

        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid get contact list request: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type GetContactsByListRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        ListID      string `json:"list_id" valid:"required,alphanum"`
}

func (r *GetContactsByListRequest) FromURLParams(queryParams url.Values) (err error) <span class="cov8" title="1">{
        r.WorkspaceID = queryParams.Get("workspace_id")
        r.ListID = queryParams.Get("list_id")

        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid get contacts by list request: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type GetListsByContactRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        Email       string `json:"email" valid:"required,email"`
}

func (r *GetListsByContactRequest) FromURLParams(queryParams url.Values) (err error) <span class="cov8" title="1">{
        r.WorkspaceID = queryParams.Get("workspace_id")
        r.Email = queryParams.Get("email")

        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid get lists by contact request: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type UpdateContactListStatusRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        Email       string `json:"email" valid:"required,email"`
        ListID      string `json:"list_id" valid:"required"`
        Status      string `json:"status" valid:"required,in(active|pending|unsubscribed|blacklisted)"`
}

func (r *UpdateContactListStatusRequest) Validate() (workspaceID string, list *ContactList, err error) <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return "", nil, fmt.Errorf("invalid update contact list status request: %w", err)
        }</span>
        <span class="cov8" title="1">return r.WorkspaceID, &amp;ContactList{
                Email:  r.Email,
                ListID: r.ListID,
                Status: ContactListStatus(r.Status),
        }, nil</span>
}

type RemoveContactFromListRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required"`
        Email       string `json:"email" valid:"required,email"`
        ListID      string `json:"list_id" valid:"required"`
}

func (r *RemoveContactFromListRequest) Validate() (err error) <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid remove contact from list request: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ContactListService provides operations for managing contact list relationships
type ContactListService interface {
        // AddContactToList adds a contact to a list
        AddContactToList(ctx context.Context, workspaceID string, contactList *ContactList) error

        // GetContactListByIDs retrieves a contact list by email and list ID
        GetContactListByIDs(ctx context.Context, workspaceID string, email, listID string) (*ContactList, error)

        // GetContactsByListID retrieves all contacts for a list
        GetContactsByListID(ctx context.Context, workspaceID string, listID string) ([]*ContactList, error)

        // GetListsByEmail retrieves all lists for a contact
        GetListsByEmail(ctx context.Context, workspaceID string, email string) ([]*ContactList, error)

        // UpdateContactListStatus updates the status of a contact on a list
        UpdateContactListStatus(ctx context.Context, workspaceID string, email, listID string, status ContactListStatus) error

        // RemoveContactFromList removes a contact from a list
        RemoveContactFromList(ctx context.Context, workspaceID string, email, listID string) error
}

type ContactListRepository interface {
        // AddContactToList adds a contact to a list
        AddContactToList(ctx context.Context, workspaceID string, contactList *ContactList) error

        // GetContactListByIDs retrieves a contact list by email and list ID
        GetContactListByIDs(ctx context.Context, workspaceID string, email, listID string) (*ContactList, error)

        // GetContactsByListID retrieves all contacts for a list
        GetContactsByListID(ctx context.Context, workspaceID string, listID string) ([]*ContactList, error)

        // GetListsByEmail retrieves all lists for a contact
        GetListsByEmail(ctx context.Context, workspaceID string, email string) ([]*ContactList, error)

        // UpdateContactListStatus updates the status of a contact on a list
        UpdateContactListStatus(ctx context.Context, workspaceID string, email, listID string, status ContactListStatus) error

        // RemoveContactFromList removes a contact from a list
        RemoveContactFromList(ctx context.Context, workspaceID string, email, listID string) error
}

// ErrContactListNotFound is returned when a contact list is not found
type ErrContactListNotFound struct {
        Message string
}

func (e *ErrContactListNotFound) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package domain

import (
        "context"
        "fmt"
        "net/url"
        "time"

        "github.com/asaskevich/govalidator"
)

//go:generate mockgen -destination mocks/mock_list_service.go -package mocks github.com/Notifuse/notifuse/internal/domain ListService
//go:generate mockgen -destination mocks/mock_list_repository.go -package mocks github.com/Notifuse/notifuse/internal/domain ListRepository

// List represents a subscription list
type List struct {
        ID            string    `json:"id" valid:"required,alphanum,stringlength(1|20)"`
        Name          string    `json:"name" valid:"required,stringlength(1|255)"`
        Type          string    `json:"type" valid:"required,in(public|private)"`
        IsDoubleOptin bool      `json:"is_double_optin" db:"is_double_optin"`
        IsPublic      bool      `json:"is_public" db:"is_public"`
        Description   string    `json:"description,omitempty" valid:"optional"`
        CreatedAt     time.Time `json:"created_at"`
        UpdatedAt     time.Time `json:"updated_at"`
}

// Validate performs validation on the list fields
func (l *List) Validate() error <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(l); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid list: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// For database scanning
type dbList struct {
        ID            string
        Name          string
        Type          string
        IsDoubleOptin bool
        IsPublic      bool
        Description   string
        CreatedAt     time.Time
        UpdatedAt     time.Time
}

// ScanList scans a list from the database
func ScanList(scanner interface {
        Scan(dest ...interface{}) error
}) (*List, error) <span class="cov8" title="1">{
        var dbl dbList
        if err := scanner.Scan(
                &amp;dbl.ID,
                &amp;dbl.Name,
                &amp;dbl.Type,
                &amp;dbl.IsDoubleOptin,
                &amp;dbl.IsPublic,
                &amp;dbl.Description,
                &amp;dbl.CreatedAt,
                &amp;dbl.UpdatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">l := &amp;List{
                ID:            dbl.ID,
                Name:          dbl.Name,
                Type:          dbl.Type,
                IsDoubleOptin: dbl.IsDoubleOptin,
                IsPublic:      dbl.IsPublic,
                Description:   dbl.Description,
                CreatedAt:     dbl.CreatedAt,
                UpdatedAt:     dbl.UpdatedAt,
        }

        return l, nil</span>
}

// Request/Response types
type CreateListRequest struct {
        WorkspaceID   string `json:"workspace_id" valid:"required,alphanum,stringlength(1|20)"`
        ID            string `json:"id" valid:"required,alphanum,stringlength(1|20)"`
        Name          string `json:"name" valid:"required,stringlength(1|255)"`
        Type          string `json:"type" valid:"required,in(public|private)"`
        IsDoubleOptin bool   `json:"is_double_optin"`
        IsPublic      bool   `json:"is_public"`
        Description   string `json:"description,omitempty"`
}

func (r *CreateListRequest) Validate() (list *List, workspaceID string, err error) <span class="cov8" title="1">{

        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("invalid create list request: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;List{
                ID:            r.ID,
                Name:          r.Name,
                Type:          r.Type,
                IsDoubleOptin: r.IsDoubleOptin,
                IsPublic:      r.IsPublic,
                Description:   r.Description,
        }, r.WorkspaceID, nil</span>
}

type GetListsRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required,alphanum,stringlength(1|20)"`
}

func (r *GetListsRequest) FromURLParams(queryParams url.Values) (err error) <span class="cov8" title="1">{
        r.WorkspaceID = queryParams.Get("workspace_id")

        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid get lists request: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type GetListRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required,alphanum,stringlength(1|20)"`
        ID          string `json:"id" valid:"required,alphanum,stringlength(1|20)"`
}

func (r *GetListRequest) FromURLParams(queryParams url.Values) (err error) <span class="cov8" title="1">{
        r.WorkspaceID = queryParams.Get("workspace_id")
        r.ID = queryParams.Get("id")

        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid get list request: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type UpdateListRequest struct {
        WorkspaceID   string `json:"workspace_id" valid:"required,alphanum,stringlength(1|20)"`
        ID            string `json:"id" valid:"required,alphanum,stringlength(1|20)"`
        Name          string `json:"name" valid:"required,stringlength(1|255)"`
        Type          string `json:"type" valid:"required,in(public|private)"`
        IsDoubleOptin bool   `json:"is_double_optin"`
        IsPublic      bool   `json:"is_public"`
        Description   string `json:"description,omitempty"`
}

func (r *UpdateListRequest) Validate() (list *List, workspaceID string, err error) <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("invalid update list request: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;List{
                ID:            r.ID,
                Name:          r.Name,
                Type:          r.Type,
                IsDoubleOptin: r.IsDoubleOptin,
                IsPublic:      r.IsPublic,
                Description:   r.Description,
        }, r.WorkspaceID, nil</span>
}

type DeleteListRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required,alphanum,stringlength(1|20)"`
        ID          string `json:"id" valid:"required,alphanum,stringlength(1|20)"`
}

func (r *DeleteListRequest) Validate() (workspaceID string, err error) <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid delete list request: %w", err)
        }</span>
        <span class="cov8" title="1">return r.WorkspaceID, nil</span>
}

// ListService provides operations for managing lists
type ListService interface {
        // CreateList creates a new list
        CreateList(ctx context.Context, workspaceID string, list *List) error

        // GetListByID retrieves a list by ID
        GetListByID(ctx context.Context, workspaceID string, id string) (*List, error)

        // GetLists retrieves all lists
        GetLists(ctx context.Context, workspaceID string) ([]*List, error)

        // UpdateList updates an existing list
        UpdateList(ctx context.Context, workspaceID string, list *List) error

        // DeleteList deletes a list by ID
        DeleteList(ctx context.Context, workspaceID string, id string) error
}

type ListRepository interface {
        // CreateList creates a new list in the database
        CreateList(ctx context.Context, workspaceID string, list *List) error

        // GetListByID retrieves a list by its ID
        GetListByID(ctx context.Context, workspaceID string, id string) (*List, error)

        // GetLists retrieves all lists
        GetLists(ctx context.Context, workspaceID string) ([]*List, error)

        // UpdateList updates an existing list
        UpdateList(ctx context.Context, workspaceID string, list *List) error

        // DeleteList deletes a list
        DeleteList(ctx context.Context, workspaceID string, id string) error
}

// ErrListNotFound is returned when a list is not found
type ErrListNotFound struct {
        Message string
}

func (e *ErrListNotFound) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: AuthRepository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        time "time"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockAuthRepository is a mock of AuthRepository interface.
type MockAuthRepository struct {
        ctrl     *gomock.Controller
        recorder *MockAuthRepositoryMockRecorder
}

// MockAuthRepositoryMockRecorder is the mock recorder for MockAuthRepository.
type MockAuthRepositoryMockRecorder struct {
        mock *MockAuthRepository
}

// NewMockAuthRepository creates a new mock instance.
func NewMockAuthRepository(ctrl *gomock.Controller) *MockAuthRepository <span class="cov0" title="0">{
        mock := &amp;MockAuthRepository{ctrl: ctrl}
        mock.recorder = &amp;MockAuthRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthRepository) EXPECT() *MockAuthRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetSessionByID mocks base method.
func (m *MockAuthRepository) GetSessionByID(arg0 context.Context, arg1, arg2 string) (*time.Time, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSessionByID", arg0, arg1, arg2)
        ret0, _ := ret[0].(*time.Time)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSessionByID indicates an expected call of GetSessionByID.
func (mr *MockAuthRepositoryMockRecorder) GetSessionByID(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSessionByID", reflect.TypeOf((*MockAuthRepository)(nil).GetSessionByID), arg0, arg1, arg2)
}</span>

// GetUserByID mocks base method.
func (m *MockAuthRepository) GetUserByID(arg0 context.Context, arg1 string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", arg0, arg1)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockAuthRepositoryMockRecorder) GetUserByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockAuthRepository)(nil).GetUserByID), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: AuthService)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        time "time"

        paseto "aidanwoods.dev/go-paseto"
        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockAuthService is a mock of AuthService interface.
type MockAuthService struct {
        ctrl     *gomock.Controller
        recorder *MockAuthServiceMockRecorder
}

// MockAuthServiceMockRecorder is the mock recorder for MockAuthService.
type MockAuthServiceMockRecorder struct {
        mock *MockAuthService
}

// NewMockAuthService creates a new mock instance.
func NewMockAuthService(ctrl *gomock.Controller) *MockAuthService <span class="cov0" title="0">{
        mock := &amp;MockAuthService{ctrl: ctrl}
        mock.recorder = &amp;MockAuthServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthService) EXPECT() *MockAuthServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AuthenticateUserForWorkspace mocks base method.
func (m *MockAuthService) AuthenticateUserForWorkspace(arg0 context.Context, arg1 string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticateUserForWorkspace", arg0, arg1)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AuthenticateUserForWorkspace indicates an expected call of AuthenticateUserForWorkspace.
func (mr *MockAuthServiceMockRecorder) AuthenticateUserForWorkspace(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticateUserForWorkspace", reflect.TypeOf((*MockAuthService)(nil).AuthenticateUserForWorkspace), arg0, arg1)
}</span>

// AuthenticateUserFromContext mocks base method.
func (m *MockAuthService) AuthenticateUserFromContext(arg0 context.Context) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticateUserFromContext", arg0)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AuthenticateUserFromContext indicates an expected call of AuthenticateUserFromContext.
func (mr *MockAuthServiceMockRecorder) AuthenticateUserFromContext(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticateUserFromContext", reflect.TypeOf((*MockAuthService)(nil).AuthenticateUserFromContext), arg0)
}</span>

// GenerateAuthToken mocks base method.
func (m *MockAuthService) GenerateAuthToken(arg0 *domain.User, arg1 string, arg2 time.Time) string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GenerateAuthToken", arg0, arg1, arg2)
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GenerateAuthToken indicates an expected call of GenerateAuthToken.
func (mr *MockAuthServiceMockRecorder) GenerateAuthToken(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateAuthToken", reflect.TypeOf((*MockAuthService)(nil).GenerateAuthToken), arg0, arg1, arg2)
}</span>

// GenerateInvitationToken mocks base method.
func (m *MockAuthService) GenerateInvitationToken(arg0 *domain.WorkspaceInvitation) string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GenerateInvitationToken", arg0)
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GenerateInvitationToken indicates an expected call of GenerateInvitationToken.
func (mr *MockAuthServiceMockRecorder) GenerateInvitationToken(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateInvitationToken", reflect.TypeOf((*MockAuthService)(nil).GenerateInvitationToken), arg0)
}</span>

// GetPrivateKey mocks base method.
func (m *MockAuthService) GetPrivateKey() paseto.V4AsymmetricSecretKey <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPrivateKey")
        ret0, _ := ret[0].(paseto.V4AsymmetricSecretKey)
        return ret0
}</span>

// GetPrivateKey indicates an expected call of GetPrivateKey.
func (mr *MockAuthServiceMockRecorder) GetPrivateKey() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPrivateKey", reflect.TypeOf((*MockAuthService)(nil).GetPrivateKey))
}</span>

// VerifyUserSession mocks base method.
func (m *MockAuthService) VerifyUserSession(arg0 context.Context, arg1, arg2 string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VerifyUserSession", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// VerifyUserSession indicates an expected call of VerifyUserSession.
func (mr *MockAuthServiceMockRecorder) VerifyUserSession(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyUserSession", reflect.TypeOf((*MockAuthService)(nil).VerifyUserSession), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: ContactListService)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockContactListService is a mock of ContactListService interface.
type MockContactListService struct {
        ctrl     *gomock.Controller
        recorder *MockContactListServiceMockRecorder
}

// MockContactListServiceMockRecorder is the mock recorder for MockContactListService.
type MockContactListServiceMockRecorder struct {
        mock *MockContactListService
}

// NewMockContactListService creates a new mock instance.
func NewMockContactListService(ctrl *gomock.Controller) *MockContactListService <span class="cov0" title="0">{
        mock := &amp;MockContactListService{ctrl: ctrl}
        mock.recorder = &amp;MockContactListServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContactListService) EXPECT() *MockContactListServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddContactToList mocks base method.
func (m *MockContactListService) AddContactToList(arg0 context.Context, arg1 string, arg2 *domain.ContactList) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddContactToList", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddContactToList indicates an expected call of AddContactToList.
func (mr *MockContactListServiceMockRecorder) AddContactToList(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddContactToList", reflect.TypeOf((*MockContactListService)(nil).AddContactToList), arg0, arg1, arg2)
}</span>

// GetContactListByIDs mocks base method.
func (m *MockContactListService) GetContactListByIDs(arg0 context.Context, arg1, arg2, arg3 string) (*domain.ContactList, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContactListByIDs", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(*domain.ContactList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContactListByIDs indicates an expected call of GetContactListByIDs.
func (mr *MockContactListServiceMockRecorder) GetContactListByIDs(arg0, arg1, arg2, arg3 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContactListByIDs", reflect.TypeOf((*MockContactListService)(nil).GetContactListByIDs), arg0, arg1, arg2, arg3)
}</span>

// GetContactsByListID mocks base method.
func (m *MockContactListService) GetContactsByListID(arg0 context.Context, arg1, arg2 string) ([]*domain.ContactList, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContactsByListID", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain.ContactList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContactsByListID indicates an expected call of GetContactsByListID.
func (mr *MockContactListServiceMockRecorder) GetContactsByListID(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContactsByListID", reflect.TypeOf((*MockContactListService)(nil).GetContactsByListID), arg0, arg1, arg2)
}</span>

// GetListsByEmail mocks base method.
func (m *MockContactListService) GetListsByEmail(arg0 context.Context, arg1, arg2 string) ([]*domain.ContactList, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetListsByEmail", arg0, arg1, arg2)
        ret0, _ := ret[0].([]*domain.ContactList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetListsByEmail indicates an expected call of GetListsByEmail.
func (mr *MockContactListServiceMockRecorder) GetListsByEmail(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetListsByEmail", reflect.TypeOf((*MockContactListService)(nil).GetListsByEmail), arg0, arg1, arg2)
}</span>

// RemoveContactFromList mocks base method.
func (m *MockContactListService) RemoveContactFromList(arg0 context.Context, arg1, arg2, arg3 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveContactFromList", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveContactFromList indicates an expected call of RemoveContactFromList.
func (mr *MockContactListServiceMockRecorder) RemoveContactFromList(arg0, arg1, arg2, arg3 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveContactFromList", reflect.TypeOf((*MockContactListService)(nil).RemoveContactFromList), arg0, arg1, arg2, arg3)
}</span>

// UpdateContactListStatus mocks base method.
func (m *MockContactListService) UpdateContactListStatus(arg0 context.Context, arg1, arg2, arg3 string, arg4 domain.ContactListStatus) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateContactListStatus", arg0, arg1, arg2, arg3, arg4)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateContactListStatus indicates an expected call of UpdateContactListStatus.
func (mr *MockContactListServiceMockRecorder) UpdateContactListStatus(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateContactListStatus", reflect.TypeOf((*MockContactListService)(nil).UpdateContactListStatus), arg0, arg1, arg2, arg3, arg4)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: ContactRepository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockContactRepository is a mock of ContactRepository interface.
type MockContactRepository struct {
        ctrl     *gomock.Controller
        recorder *MockContactRepositoryMockRecorder
}

// MockContactRepositoryMockRecorder is the mock recorder for MockContactRepository.
type MockContactRepositoryMockRecorder struct {
        mock *MockContactRepository
}

// NewMockContactRepository creates a new mock instance.
func NewMockContactRepository(ctrl *gomock.Controller) *MockContactRepository <span class="cov0" title="0">{
        mock := &amp;MockContactRepository{ctrl: ctrl}
        mock.recorder = &amp;MockContactRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContactRepository) EXPECT() *MockContactRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// BatchImportContacts mocks base method.
func (m *MockContactRepository) BatchImportContacts(arg0 context.Context, arg1 string, arg2 []*domain.Contact) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchImportContacts", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BatchImportContacts indicates an expected call of BatchImportContacts.
func (mr *MockContactRepositoryMockRecorder) BatchImportContacts(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchImportContacts", reflect.TypeOf((*MockContactRepository)(nil).BatchImportContacts), arg0, arg1, arg2)
}</span>

// DeleteContact mocks base method.
func (m *MockContactRepository) DeleteContact(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteContact", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteContact indicates an expected call of DeleteContact.
func (mr *MockContactRepositoryMockRecorder) DeleteContact(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteContact", reflect.TypeOf((*MockContactRepository)(nil).DeleteContact), arg0, arg1, arg2)
}</span>

// GetContactByEmail mocks base method.
func (m *MockContactRepository) GetContactByEmail(arg0 context.Context, arg1, arg2 string) (*domain.Contact, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContactByEmail", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.Contact)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContactByEmail indicates an expected call of GetContactByEmail.
func (mr *MockContactRepositoryMockRecorder) GetContactByEmail(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContactByEmail", reflect.TypeOf((*MockContactRepository)(nil).GetContactByEmail), arg0, arg1, arg2)
}</span>

// GetContactByExternalID mocks base method.
func (m *MockContactRepository) GetContactByExternalID(arg0 context.Context, arg1, arg2 string) (*domain.Contact, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContactByExternalID", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.Contact)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContactByExternalID indicates an expected call of GetContactByExternalID.
func (mr *MockContactRepositoryMockRecorder) GetContactByExternalID(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContactByExternalID", reflect.TypeOf((*MockContactRepository)(nil).GetContactByExternalID), arg0, arg1, arg2)
}</span>

// GetContacts mocks base method.
func (m *MockContactRepository) GetContacts(arg0 context.Context, arg1 *domain.GetContactsRequest) (*domain.GetContactsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContacts", arg0, arg1)
        ret0, _ := ret[0].(*domain.GetContactsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContacts indicates an expected call of GetContacts.
func (mr *MockContactRepositoryMockRecorder) GetContacts(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContacts", reflect.TypeOf((*MockContactRepository)(nil).GetContacts), arg0, arg1)
}</span>

// UpsertContact mocks base method.
func (m *MockContactRepository) UpsertContact(arg0 context.Context, arg1 string, arg2 *domain.Contact) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpsertContact", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpsertContact indicates an expected call of UpsertContact.
func (mr *MockContactRepositoryMockRecorder) UpsertContact(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertContact", reflect.TypeOf((*MockContactRepository)(nil).UpsertContact), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: ContactService)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockContactService is a mock of ContactService interface.
type MockContactService struct {
        ctrl     *gomock.Controller
        recorder *MockContactServiceMockRecorder
}

// MockContactServiceMockRecorder is the mock recorder for MockContactService.
type MockContactServiceMockRecorder struct {
        mock *MockContactService
}

// NewMockContactService creates a new mock instance.
func NewMockContactService(ctrl *gomock.Controller) *MockContactService <span class="cov0" title="0">{
        mock := &amp;MockContactService{ctrl: ctrl}
        mock.recorder = &amp;MockContactServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContactService) EXPECT() *MockContactServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// BatchImportContacts mocks base method.
func (m *MockContactService) BatchImportContacts(arg0 context.Context, arg1 string, arg2 []*domain.Contact) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchImportContacts", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BatchImportContacts indicates an expected call of BatchImportContacts.
func (mr *MockContactServiceMockRecorder) BatchImportContacts(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchImportContacts", reflect.TypeOf((*MockContactService)(nil).BatchImportContacts), arg0, arg1, arg2)
}</span>

// DeleteContact mocks base method.
func (m *MockContactService) DeleteContact(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteContact", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteContact indicates an expected call of DeleteContact.
func (mr *MockContactServiceMockRecorder) DeleteContact(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteContact", reflect.TypeOf((*MockContactService)(nil).DeleteContact), arg0, arg1, arg2)
}</span>

// GetContactByEmail mocks base method.
func (m *MockContactService) GetContactByEmail(arg0 context.Context, arg1, arg2 string) (*domain.Contact, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContactByEmail", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.Contact)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContactByEmail indicates an expected call of GetContactByEmail.
func (mr *MockContactServiceMockRecorder) GetContactByEmail(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContactByEmail", reflect.TypeOf((*MockContactService)(nil).GetContactByEmail), arg0, arg1, arg2)
}</span>

// GetContactByExternalID mocks base method.
func (m *MockContactService) GetContactByExternalID(arg0 context.Context, arg1, arg2 string) (*domain.Contact, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContactByExternalID", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.Contact)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContactByExternalID indicates an expected call of GetContactByExternalID.
func (mr *MockContactServiceMockRecorder) GetContactByExternalID(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContactByExternalID", reflect.TypeOf((*MockContactService)(nil).GetContactByExternalID), arg0, arg1, arg2)
}</span>

// GetContacts mocks base method.
func (m *MockContactService) GetContacts(arg0 context.Context, arg1 *domain.GetContactsRequest) (*domain.GetContactsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetContacts", arg0, arg1)
        ret0, _ := ret[0].(*domain.GetContactsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetContacts indicates an expected call of GetContacts.
func (mr *MockContactServiceMockRecorder) GetContacts(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContacts", reflect.TypeOf((*MockContactService)(nil).GetContacts), arg0, arg1)
}</span>

// UpsertContact mocks base method.
func (m *MockContactService) UpsertContact(arg0 context.Context, arg1 string, arg2 *domain.Contact) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpsertContact", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpsertContact indicates an expected call of UpsertContact.
func (mr *MockContactServiceMockRecorder) UpsertContact(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertContact", reflect.TypeOf((*MockContactService)(nil).UpsertContact), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: ListRepository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockListRepository is a mock of ListRepository interface.
type MockListRepository struct {
        ctrl     *gomock.Controller
        recorder *MockListRepositoryMockRecorder
}

// MockListRepositoryMockRecorder is the mock recorder for MockListRepository.
type MockListRepositoryMockRecorder struct {
        mock *MockListRepository
}

// NewMockListRepository creates a new mock instance.
func NewMockListRepository(ctrl *gomock.Controller) *MockListRepository <span class="cov0" title="0">{
        mock := &amp;MockListRepository{ctrl: ctrl}
        mock.recorder = &amp;MockListRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListRepository) EXPECT() *MockListRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateList mocks base method.
func (m *MockListRepository) CreateList(arg0 context.Context, arg1 string, arg2 *domain.List) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateList", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateList indicates an expected call of CreateList.
func (mr *MockListRepositoryMockRecorder) CreateList(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateList", reflect.TypeOf((*MockListRepository)(nil).CreateList), arg0, arg1, arg2)
}</span>

// DeleteList mocks base method.
func (m *MockListRepository) DeleteList(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteList", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteList indicates an expected call of DeleteList.
func (mr *MockListRepositoryMockRecorder) DeleteList(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteList", reflect.TypeOf((*MockListRepository)(nil).DeleteList), arg0, arg1, arg2)
}</span>

// GetListByID mocks base method.
func (m *MockListRepository) GetListByID(arg0 context.Context, arg1, arg2 string) (*domain.List, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetListByID", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.List)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetListByID indicates an expected call of GetListByID.
func (mr *MockListRepositoryMockRecorder) GetListByID(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetListByID", reflect.TypeOf((*MockListRepository)(nil).GetListByID), arg0, arg1, arg2)
}</span>

// GetLists mocks base method.
func (m *MockListRepository) GetLists(arg0 context.Context, arg1 string) ([]*domain.List, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLists", arg0, arg1)
        ret0, _ := ret[0].([]*domain.List)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLists indicates an expected call of GetLists.
func (mr *MockListRepositoryMockRecorder) GetLists(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLists", reflect.TypeOf((*MockListRepository)(nil).GetLists), arg0, arg1)
}</span>

// UpdateList mocks base method.
func (m *MockListRepository) UpdateList(arg0 context.Context, arg1 string, arg2 *domain.List) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateList", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateList indicates an expected call of UpdateList.
func (mr *MockListRepositoryMockRecorder) UpdateList(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateList", reflect.TypeOf((*MockListRepository)(nil).UpdateList), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: ListService)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockListService is a mock of ListService interface.
type MockListService struct {
        ctrl     *gomock.Controller
        recorder *MockListServiceMockRecorder
}

// MockListServiceMockRecorder is the mock recorder for MockListService.
type MockListServiceMockRecorder struct {
        mock *MockListService
}

// NewMockListService creates a new mock instance.
func NewMockListService(ctrl *gomock.Controller) *MockListService <span class="cov0" title="0">{
        mock := &amp;MockListService{ctrl: ctrl}
        mock.recorder = &amp;MockListServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListService) EXPECT() *MockListServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateList mocks base method.
func (m *MockListService) CreateList(arg0 context.Context, arg1 string, arg2 *domain.List) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateList", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateList indicates an expected call of CreateList.
func (mr *MockListServiceMockRecorder) CreateList(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateList", reflect.TypeOf((*MockListService)(nil).CreateList), arg0, arg1, arg2)
}</span>

// DeleteList mocks base method.
func (m *MockListService) DeleteList(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteList", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteList indicates an expected call of DeleteList.
func (mr *MockListServiceMockRecorder) DeleteList(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteList", reflect.TypeOf((*MockListService)(nil).DeleteList), arg0, arg1, arg2)
}</span>

// GetListByID mocks base method.
func (m *MockListService) GetListByID(arg0 context.Context, arg1, arg2 string) (*domain.List, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetListByID", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.List)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetListByID indicates an expected call of GetListByID.
func (mr *MockListServiceMockRecorder) GetListByID(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetListByID", reflect.TypeOf((*MockListService)(nil).GetListByID), arg0, arg1, arg2)
}</span>

// GetLists mocks base method.
func (m *MockListService) GetLists(arg0 context.Context, arg1 string) ([]*domain.List, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLists", arg0, arg1)
        ret0, _ := ret[0].([]*domain.List)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLists indicates an expected call of GetLists.
func (mr *MockListServiceMockRecorder) GetLists(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLists", reflect.TypeOf((*MockListService)(nil).GetLists), arg0, arg1)
}</span>

// UpdateList mocks base method.
func (m *MockListService) UpdateList(arg0 context.Context, arg1 string, arg2 *domain.List) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateList", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateList indicates an expected call of UpdateList.
func (mr *MockListServiceMockRecorder) UpdateList(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateList", reflect.TypeOf((*MockListService)(nil).UpdateList), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: UserServiceInterface)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockUserServiceInterface is a mock of UserServiceInterface interface.
type MockUserServiceInterface struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceInterfaceMockRecorder
}

// MockUserServiceInterfaceMockRecorder is the mock recorder for MockUserServiceInterface.
type MockUserServiceInterfaceMockRecorder struct {
        mock *MockUserServiceInterface
}

// NewMockUserServiceInterface creates a new mock instance.
func NewMockUserServiceInterface(ctrl *gomock.Controller) *MockUserServiceInterface <span class="cov0" title="0">{
        mock := &amp;MockUserServiceInterface{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserServiceInterface) EXPECT() *MockUserServiceInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetUserByEmail mocks base method.
func (m *MockUserServiceInterface) GetUserByEmail(arg0 context.Context, arg1 string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByEmail", arg0, arg1)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByEmail indicates an expected call of GetUserByEmail.
func (mr *MockUserServiceInterfaceMockRecorder) GetUserByEmail(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByEmail", reflect.TypeOf((*MockUserServiceInterface)(nil).GetUserByEmail), arg0, arg1)
}</span>

// GetUserByID mocks base method.
func (m *MockUserServiceInterface) GetUserByID(arg0 context.Context, arg1 string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", arg0, arg1)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserServiceInterfaceMockRecorder) GetUserByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserServiceInterface)(nil).GetUserByID), arg0, arg1)
}</span>

// SignIn mocks base method.
func (m *MockUserServiceInterface) SignIn(arg0 context.Context, arg1 domain.SignInInput) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignIn", arg0, arg1)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SignIn indicates an expected call of SignIn.
func (mr *MockUserServiceInterfaceMockRecorder) SignIn(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignIn", reflect.TypeOf((*MockUserServiceInterface)(nil).SignIn), arg0, arg1)
}</span>

// VerifyCode mocks base method.
func (m *MockUserServiceInterface) VerifyCode(arg0 context.Context, arg1 domain.VerifyCodeInput) (*domain.AuthResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VerifyCode", arg0, arg1)
        ret0, _ := ret[0].(*domain.AuthResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// VerifyCode indicates an expected call of VerifyCode.
func (mr *MockUserServiceInterfaceMockRecorder) VerifyCode(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyCode", reflect.TypeOf((*MockUserServiceInterface)(nil).VerifyCode), arg0, arg1)
}</span>

// VerifyUserSession mocks base method.
func (m *MockUserServiceInterface) VerifyUserSession(arg0 context.Context, arg1, arg2 string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VerifyUserSession", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// VerifyUserSession indicates an expected call of VerifyUserSession.
func (mr *MockUserServiceInterfaceMockRecorder) VerifyUserSession(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyUserSession", reflect.TypeOf((*MockUserServiceInterface)(nil).VerifyUserSession), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: WorkspaceRepository)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        sql "database/sql"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockWorkspaceRepository is a mock of WorkspaceRepository interface.
type MockWorkspaceRepository struct {
        ctrl     *gomock.Controller
        recorder *MockWorkspaceRepositoryMockRecorder
}

// MockWorkspaceRepositoryMockRecorder is the mock recorder for MockWorkspaceRepository.
type MockWorkspaceRepositoryMockRecorder struct {
        mock *MockWorkspaceRepository
}

// NewMockWorkspaceRepository creates a new mock instance.
func NewMockWorkspaceRepository(ctrl *gomock.Controller) *MockWorkspaceRepository <span class="cov0" title="0">{
        mock := &amp;MockWorkspaceRepository{ctrl: ctrl}
        mock.recorder = &amp;MockWorkspaceRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkspaceRepository) EXPECT() *MockWorkspaceRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddUserToWorkspace mocks base method.
func (m *MockWorkspaceRepository) AddUserToWorkspace(arg0 context.Context, arg1 *domain.UserWorkspace) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddUserToWorkspace", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddUserToWorkspace indicates an expected call of AddUserToWorkspace.
func (mr *MockWorkspaceRepositoryMockRecorder) AddUserToWorkspace(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUserToWorkspace", reflect.TypeOf((*MockWorkspaceRepository)(nil).AddUserToWorkspace), arg0, arg1)
}</span>

// Create mocks base method.
func (m *MockWorkspaceRepository) Create(arg0 context.Context, arg1 *domain.Workspace) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockWorkspaceRepositoryMockRecorder) Create(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockWorkspaceRepository)(nil).Create), arg0, arg1)
}</span>

// CreateDatabase mocks base method.
func (m *MockWorkspaceRepository) CreateDatabase(arg0 context.Context, arg1 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateDatabase", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateDatabase indicates an expected call of CreateDatabase.
func (mr *MockWorkspaceRepositoryMockRecorder) CreateDatabase(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDatabase", reflect.TypeOf((*MockWorkspaceRepository)(nil).CreateDatabase), arg0, arg1)
}</span>

// CreateInvitation mocks base method.
func (m *MockWorkspaceRepository) CreateInvitation(arg0 context.Context, arg1 *domain.WorkspaceInvitation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateInvitation", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateInvitation indicates an expected call of CreateInvitation.
func (mr *MockWorkspaceRepositoryMockRecorder) CreateInvitation(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInvitation", reflect.TypeOf((*MockWorkspaceRepository)(nil).CreateInvitation), arg0, arg1)
}</span>

// Delete mocks base method.
func (m *MockWorkspaceRepository) Delete(arg0 context.Context, arg1 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockWorkspaceRepositoryMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockWorkspaceRepository)(nil).Delete), arg0, arg1)
}</span>

// DeleteDatabase mocks base method.
func (m *MockWorkspaceRepository) DeleteDatabase(arg0 context.Context, arg1 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteDatabase", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteDatabase indicates an expected call of DeleteDatabase.
func (mr *MockWorkspaceRepositoryMockRecorder) DeleteDatabase(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDatabase", reflect.TypeOf((*MockWorkspaceRepository)(nil).DeleteDatabase), arg0, arg1)
}</span>

// GetByID mocks base method.
func (m *MockWorkspaceRepository) GetByID(arg0 context.Context, arg1 string) (*domain.Workspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", arg0, arg1)
        ret0, _ := ret[0].(*domain.Workspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockWorkspaceRepositoryMockRecorder) GetByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockWorkspaceRepository)(nil).GetByID), arg0, arg1)
}</span>

// GetConnection mocks base method.
func (m *MockWorkspaceRepository) GetConnection(arg0 context.Context, arg1 string) (*sql.DB, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetConnection", arg0, arg1)
        ret0, _ := ret[0].(*sql.DB)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetConnection indicates an expected call of GetConnection.
func (mr *MockWorkspaceRepositoryMockRecorder) GetConnection(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConnection", reflect.TypeOf((*MockWorkspaceRepository)(nil).GetConnection), arg0, arg1)
}</span>

// GetInvitationByEmail mocks base method.
func (m *MockWorkspaceRepository) GetInvitationByEmail(arg0 context.Context, arg1, arg2 string) (*domain.WorkspaceInvitation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInvitationByEmail", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.WorkspaceInvitation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInvitationByEmail indicates an expected call of GetInvitationByEmail.
func (mr *MockWorkspaceRepositoryMockRecorder) GetInvitationByEmail(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInvitationByEmail", reflect.TypeOf((*MockWorkspaceRepository)(nil).GetInvitationByEmail), arg0, arg1, arg2)
}</span>

// GetInvitationByID mocks base method.
func (m *MockWorkspaceRepository) GetInvitationByID(arg0 context.Context, arg1 string) (*domain.WorkspaceInvitation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInvitationByID", arg0, arg1)
        ret0, _ := ret[0].(*domain.WorkspaceInvitation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInvitationByID indicates an expected call of GetInvitationByID.
func (mr *MockWorkspaceRepositoryMockRecorder) GetInvitationByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInvitationByID", reflect.TypeOf((*MockWorkspaceRepository)(nil).GetInvitationByID), arg0, arg1)
}</span>

// GetUserWorkspace mocks base method.
func (m *MockWorkspaceRepository) GetUserWorkspace(arg0 context.Context, arg1, arg2 string) (*domain.UserWorkspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserWorkspace", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.UserWorkspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserWorkspace indicates an expected call of GetUserWorkspace.
func (mr *MockWorkspaceRepositoryMockRecorder) GetUserWorkspace(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserWorkspace", reflect.TypeOf((*MockWorkspaceRepository)(nil).GetUserWorkspace), arg0, arg1, arg2)
}</span>

// GetUserWorkspaces mocks base method.
func (m *MockWorkspaceRepository) GetUserWorkspaces(arg0 context.Context, arg1 string) ([]*domain.UserWorkspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserWorkspaces", arg0, arg1)
        ret0, _ := ret[0].([]*domain.UserWorkspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserWorkspaces indicates an expected call of GetUserWorkspaces.
func (mr *MockWorkspaceRepositoryMockRecorder) GetUserWorkspaces(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserWorkspaces", reflect.TypeOf((*MockWorkspaceRepository)(nil).GetUserWorkspaces), arg0, arg1)
}</span>

// GetWorkspaceUsersWithEmail mocks base method.
func (m *MockWorkspaceRepository) GetWorkspaceUsersWithEmail(arg0 context.Context, arg1 string) ([]*domain.UserWorkspaceWithEmail, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWorkspaceUsersWithEmail", arg0, arg1)
        ret0, _ := ret[0].([]*domain.UserWorkspaceWithEmail)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWorkspaceUsersWithEmail indicates an expected call of GetWorkspaceUsersWithEmail.
func (mr *MockWorkspaceRepositoryMockRecorder) GetWorkspaceUsersWithEmail(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkspaceUsersWithEmail", reflect.TypeOf((*MockWorkspaceRepository)(nil).GetWorkspaceUsersWithEmail), arg0, arg1)
}</span>

// IsUserWorkspaceMember mocks base method.
func (m *MockWorkspaceRepository) IsUserWorkspaceMember(arg0 context.Context, arg1, arg2 string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsUserWorkspaceMember", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsUserWorkspaceMember indicates an expected call of IsUserWorkspaceMember.
func (mr *MockWorkspaceRepositoryMockRecorder) IsUserWorkspaceMember(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUserWorkspaceMember", reflect.TypeOf((*MockWorkspaceRepository)(nil).IsUserWorkspaceMember), arg0, arg1, arg2)
}</span>

// List mocks base method.
func (m *MockWorkspaceRepository) List(arg0 context.Context) ([]*domain.Workspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", arg0)
        ret0, _ := ret[0].([]*domain.Workspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockWorkspaceRepositoryMockRecorder) List(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockWorkspaceRepository)(nil).List), arg0)
}</span>

// RemoveUserFromWorkspace mocks base method.
func (m *MockWorkspaceRepository) RemoveUserFromWorkspace(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveUserFromWorkspace", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveUserFromWorkspace indicates an expected call of RemoveUserFromWorkspace.
func (mr *MockWorkspaceRepositoryMockRecorder) RemoveUserFromWorkspace(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveUserFromWorkspace", reflect.TypeOf((*MockWorkspaceRepository)(nil).RemoveUserFromWorkspace), arg0, arg1, arg2)
}</span>

// Update mocks base method.
func (m *MockWorkspaceRepository) Update(arg0 context.Context, arg1 *domain.Workspace) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockWorkspaceRepositoryMockRecorder) Update(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockWorkspaceRepository)(nil).Update), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Notifuse/notifuse/internal/domain (interfaces: WorkspaceServiceInterface)

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        domain "github.com/Notifuse/notifuse/internal/domain"
        gomock "github.com/golang/mock/gomock"
)

// MockWorkspaceServiceInterface is a mock of WorkspaceServiceInterface interface.
type MockWorkspaceServiceInterface struct {
        ctrl     *gomock.Controller
        recorder *MockWorkspaceServiceInterfaceMockRecorder
}

// MockWorkspaceServiceInterfaceMockRecorder is the mock recorder for MockWorkspaceServiceInterface.
type MockWorkspaceServiceInterfaceMockRecorder struct {
        mock *MockWorkspaceServiceInterface
}

// NewMockWorkspaceServiceInterface creates a new mock instance.
func NewMockWorkspaceServiceInterface(ctrl *gomock.Controller) *MockWorkspaceServiceInterface <span class="cov0" title="0">{
        mock := &amp;MockWorkspaceServiceInterface{ctrl: ctrl}
        mock.recorder = &amp;MockWorkspaceServiceInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkspaceServiceInterface) EXPECT() *MockWorkspaceServiceInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddUserToWorkspace mocks base method.
func (m *MockWorkspaceServiceInterface) AddUserToWorkspace(arg0 context.Context, arg1, arg2, arg3 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddUserToWorkspace", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddUserToWorkspace indicates an expected call of AddUserToWorkspace.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) AddUserToWorkspace(arg0, arg1, arg2, arg3 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUserToWorkspace", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).AddUserToWorkspace), arg0, arg1, arg2, arg3)
}</span>

// CreateWorkspace mocks base method.
func (m *MockWorkspaceServiceInterface) CreateWorkspace(arg0 context.Context, arg1, arg2, arg3, arg4, arg5, arg6 string) (*domain.Workspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateWorkspace", arg0, arg1, arg2, arg3, arg4, arg5, arg6)
        ret0, _ := ret[0].(*domain.Workspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateWorkspace indicates an expected call of CreateWorkspace.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) CreateWorkspace(arg0, arg1, arg2, arg3, arg4, arg5, arg6 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkspace", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).CreateWorkspace), arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}</span>

// DeleteWorkspace mocks base method.
func (m *MockWorkspaceServiceInterface) DeleteWorkspace(arg0 context.Context, arg1 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteWorkspace", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteWorkspace indicates an expected call of DeleteWorkspace.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) DeleteWorkspace(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkspace", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).DeleteWorkspace), arg0, arg1)
}</span>

// GetWorkspace mocks base method.
func (m *MockWorkspaceServiceInterface) GetWorkspace(arg0 context.Context, arg1 string) (*domain.Workspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWorkspace", arg0, arg1)
        ret0, _ := ret[0].(*domain.Workspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWorkspace indicates an expected call of GetWorkspace.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) GetWorkspace(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkspace", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).GetWorkspace), arg0, arg1)
}</span>

// GetWorkspaceMembersWithEmail mocks base method.
func (m *MockWorkspaceServiceInterface) GetWorkspaceMembersWithEmail(arg0 context.Context, arg1 string) ([]*domain.UserWorkspaceWithEmail, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWorkspaceMembersWithEmail", arg0, arg1)
        ret0, _ := ret[0].([]*domain.UserWorkspaceWithEmail)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWorkspaceMembersWithEmail indicates an expected call of GetWorkspaceMembersWithEmail.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) GetWorkspaceMembersWithEmail(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkspaceMembersWithEmail", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).GetWorkspaceMembersWithEmail), arg0, arg1)
}</span>

// InviteMember mocks base method.
func (m *MockWorkspaceServiceInterface) InviteMember(arg0 context.Context, arg1, arg2 string) (*domain.WorkspaceInvitation, string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InviteMember", arg0, arg1, arg2)
        ret0, _ := ret[0].(*domain.WorkspaceInvitation)
        ret1, _ := ret[1].(string)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// InviteMember indicates an expected call of InviteMember.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) InviteMember(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InviteMember", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).InviteMember), arg0, arg1, arg2)
}</span>

// ListWorkspaces mocks base method.
func (m *MockWorkspaceServiceInterface) ListWorkspaces(arg0 context.Context) ([]*domain.Workspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListWorkspaces", arg0)
        ret0, _ := ret[0].([]*domain.Workspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListWorkspaces indicates an expected call of ListWorkspaces.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) ListWorkspaces(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkspaces", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).ListWorkspaces), arg0)
}</span>

// RemoveUserFromWorkspace mocks base method.
func (m *MockWorkspaceServiceInterface) RemoveUserFromWorkspace(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveUserFromWorkspace", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveUserFromWorkspace indicates an expected call of RemoveUserFromWorkspace.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) RemoveUserFromWorkspace(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveUserFromWorkspace", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).RemoveUserFromWorkspace), arg0, arg1, arg2)
}</span>

// TransferOwnership mocks base method.
func (m *MockWorkspaceServiceInterface) TransferOwnership(arg0 context.Context, arg1, arg2, arg3 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TransferOwnership", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// TransferOwnership indicates an expected call of TransferOwnership.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) TransferOwnership(arg0, arg1, arg2, arg3 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransferOwnership", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).TransferOwnership), arg0, arg1, arg2, arg3)
}</span>

// UpdateWorkspace mocks base method.
func (m *MockWorkspaceServiceInterface) UpdateWorkspace(arg0 context.Context, arg1, arg2, arg3, arg4, arg5, arg6 string) (*domain.Workspace, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateWorkspace", arg0, arg1, arg2, arg3, arg4, arg5, arg6)
        ret0, _ := ret[0].(*domain.Workspace)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateWorkspace indicates an expected call of UpdateWorkspace.
func (mr *MockWorkspaceServiceInterfaceMockRecorder) UpdateWorkspace(arg0, arg1, arg2, arg3, arg4, arg5, arg6 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkspace", reflect.TypeOf((*MockWorkspaceServiceInterface)(nil).UpdateWorkspace), arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package domain

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
)

// NullableJSON represents a JSON object that can be null.
// It implements database/sql.Scanner and driver.Valuer interfaces
// for proper database handling, as well as json.Marshaler and
// json.Unmarshaler for JSON encoding/decoding.
type NullableJSON struct {
        Data   interface{}
        IsNull bool
}

// Scan implements the sql.Scanner interface.
// It scans a value from the database into the NullableJSON struct.
func (nj *NullableJSON) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                nj.Data = nil
                nj.IsNull = true
                return nil
        }</span>

        // Handle byte slice from database
        <span class="cov8" title="1">switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                if len(v) == 0 </span><span class="cov8" title="1">{
                        nj.Data = nil
                        nj.IsNull = true
                        return nil
                }</span>
                <span class="cov8" title="1">var data interface{}
                if err := json.Unmarshal(v, &amp;data); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">nj.Data = data
                nj.IsNull = false
                return nil</span>
        case string:<span class="cov8" title="1">
                if v == "" </span><span class="cov8" title="1">{
                        nj.Data = nil
                        nj.IsNull = true
                        return nil
                }</span>
                <span class="cov8" title="1">var data interface{}
                if err := json.Unmarshal([]byte(v), &amp;data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">nj.Data = data
                nj.IsNull = false
                return nil</span>
        default:<span class="cov8" title="1">
                return errors.New("incompatible type for NullableJSON")</span>
        }
}

// Value implements the driver.Valuer interface.
// It returns a value suitable for database storage.
func (nj NullableJSON) Value() (driver.Value, error) <span class="cov8" title="1">{
        if nj.IsNull || nj.Data == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return json.Marshal(nj.Data)</span>
}

// MarshalJSON implements the json.Marshaler interface.
// It handles the JSON encoding of the NullableJSON value.
func (nj NullableJSON) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if nj.IsNull || nj.Data == nil </span><span class="cov8" title="1">{
                return []byte("null"), nil
        }</span>
        <span class="cov8" title="1">return json.Marshal(nj.Data)</span>
}

// UnmarshalJSON implements the json.Unmarshaler interface.
// It handles the JSON decoding into a NullableJSON value.
func (nj *NullableJSON) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Handle null case
        if string(data) == "null" </span><span class="cov8" title="1">{
                nj.Data = nil
                nj.IsNull = true
                return nil
        }</span>

        <span class="cov8" title="1">var value interface{}
        if err := json.Unmarshal(data, &amp;value); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nj.Data = value
        nj.IsNull = false
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package domain

import (
        "database/sql"
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"
)

// NullableString represents a string that can be null
type NullableString struct {
        String string
        IsNull bool
}

// Value implements the driver.Valuer interface for database/sql
func (ns NullableString) Value() (driver.Value, error) <span class="cov8" title="1">{
        if ns.IsNull </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return ns.String, nil</span>
}

// Scan implements the sql.Scanner interface for database/sql
func (ns *NullableString) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                ns.String = ""
                ns.IsNull = true
                return nil
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                ns.String = v
                ns.IsNull = false
                return nil</span>
        case []byte:<span class="cov8" title="1">
                ns.String = string(v)
                ns.IsNull = false
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into NullableString", value)</span>
        }
}

// MarshalJSON implements json.Marshaler
func (ns NullableString) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if ns.IsNull </span><span class="cov8" title="1">{
                return []byte("null"), nil
        }</span>
        <span class="cov8" title="1">return []byte(`"` + ns.String + `"`), nil</span>
}

// UnmarshalJSON implements json.Unmarshaler
func (ns *NullableString) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Handle null case
        if string(data) == "null" </span><span class="cov8" title="1">{
                ns.String = ""
                ns.IsNull = true
                return nil
        }</span>

        // Try to unmarshal as a string first
        <span class="cov8" title="1">var str string
        if err := json.Unmarshal(data, &amp;str); err == nil </span><span class="cov8" title="1">{
                ns.String = str
                ns.IsNull = false
                return nil
        }</span>

        // If that fails, try to unmarshal as an object
        <span class="cov0" title="0">var obj struct {
                String string `json:"String"`
                IsNull bool   `json:"IsNull"`
        }
        if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ns.String = obj.String
        ns.IsNull = obj.IsNull
        return nil</span>
}

// NullableFloat64 represents a float64 that can be null
type NullableFloat64 struct {
        Float64 float64
        IsNull  bool
}

// Value implements the driver.Valuer interface for database/sql
func (nf NullableFloat64) Value() (driver.Value, error) <span class="cov8" title="1">{
        if nf.IsNull </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return nf.Float64, nil</span>
}

// Scan implements the sql.Scanner interface for database/sql
func (nf *NullableFloat64) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                nf.Float64 = 0
                nf.IsNull = true
                return nil
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case float64:<span class="cov8" title="1">
                nf.Float64 = v
                nf.IsNull = false
                return nil</span>
        case int64:<span class="cov8" title="1">
                nf.Float64 = float64(v)
                nf.IsNull = false
                return nil</span>
        case []byte:<span class="cov8" title="1">
                // Try to convert []byte to float64
                var f sql.NullFloat64
                if err := f.Scan(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">nf.Float64 = f.Float64
                nf.IsNull = !f.Valid
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into NullableFloat64", value)</span>
        }
}

// MarshalJSON implements json.Marshaler
func (nf NullableFloat64) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if nf.IsNull </span><span class="cov8" title="1">{
                return []byte("null"), nil
        }</span>
        <span class="cov8" title="1">return []byte(fmt.Sprintf("%f", nf.Float64)), nil</span>
}

// UnmarshalJSON implements json.Unmarshaler
func (nf *NullableFloat64) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Handle null case
        if string(data) == "null" </span><span class="cov8" title="1">{
                nf.Float64 = 0
                nf.IsNull = true
                return nil
        }</span>

        // Try to unmarshal as a float64 first
        <span class="cov8" title="1">var f float64
        if err := json.Unmarshal(data, &amp;f); err == nil </span><span class="cov8" title="1">{
                nf.Float64 = f
                nf.IsNull = false
                return nil
        }</span>

        // If that fails, try to unmarshal as an object
        <span class="cov0" title="0">var obj struct {
                Float64 float64 `json:"Float64"`
                IsNull  bool    `json:"IsNull"`
        }
        if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">nf.Float64 = obj.Float64
        nf.IsNull = obj.IsNull
        return nil</span>
}

// NullableTime represents a time.Time that can be null
type NullableTime struct {
        Time   time.Time
        IsNull bool
}

// Value implements the driver.Valuer interface for database/sql
func (nt NullableTime) Value() (driver.Value, error) <span class="cov8" title="1">{
        if nt.IsNull </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return nt.Time, nil</span>
}

// Scan implements the sql.Scanner interface for database/sql
func (nt *NullableTime) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                nt.Time = time.Time{}
                nt.IsNull = true
                return nil
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case time.Time:<span class="cov8" title="1">
                nt.Time = v
                nt.IsNull = false
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into NullableTime", value)</span>
        }
}

// MarshalJSON implements json.Marshaler
func (nt NullableTime) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if nt.IsNull </span><span class="cov8" title="1">{
                return []byte("null"), nil
        }</span>
        <span class="cov8" title="1">return []byte(fmt.Sprintf(`"%s"`, nt.Time.Format(time.RFC3339))), nil</span>
}

// UnmarshalJSON implements json.Unmarshaler
func (nt *NullableTime) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Handle null case
        if string(data) == "null" </span><span class="cov8" title="1">{
                nt.Time = time.Time{}
                nt.IsNull = true
                return nil
        }</span>

        // Try to unmarshal as a string first
        <span class="cov8" title="1">var str string
        if err := json.Unmarshal(data, &amp;str); err == nil </span><span class="cov8" title="1">{
                // Try to parse the time string
                t, err := time.Parse(time.RFC3339, str)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">nt.Time = t
                nt.IsNull = false
                return nil</span>
        }

        // If that fails, try to unmarshal as an object
        <span class="cov0" title="0">var obj struct {
                Time   time.Time `json:"Time"`
                IsNull bool      `json:"IsNull"`
        }
        if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">nt.Time = obj.Time
        nt.IsNull = obj.IsNull
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package domain

// Timezones contains all valid IANA timezone identifiers
var Timezones = []string{
        "Africa/Abidjan",
        "Africa/Accra",
        "Africa/Addis_Ababa",
        "Africa/Algiers",
        "Africa/Asmara",
        "Africa/Bamako",
        "Africa/Bangui",
        "Africa/Banjul",
        "Africa/Bissau",
        "Africa/Blantyre",
        "Africa/Brazzaville",
        "Africa/Bujumbura",
        "Africa/Cairo",
        "Africa/Casablanca",
        "Africa/Ceuta",
        "Africa/Conakry",
        "Africa/Dakar",
        "Africa/Dar_es_Salaam",
        "Africa/Djibouti",
        "Africa/Douala",
        "Africa/El_Aaiun",
        "Africa/Freetown",
        "Africa/Gaborone",
        "Africa/Harare",
        "Africa/Johannesburg",
        "Africa/Juba",
        "Africa/Kampala",
        "Africa/Khartoum",
        "Africa/Kigali",
        "Africa/Kinshasa",
        "Africa/Lagos",
        "Africa/Libreville",
        "Africa/Lome",
        "Africa/Luanda",
        "Africa/Lubumbashi",
        "Africa/Lusaka",
        "Africa/Malabo",
        "Africa/Maputo",
        "Africa/Maseru",
        "Africa/Mbabane",
        "Africa/Mogadishu",
        "Africa/Monrovia",
        "Africa/Nairobi",
        "Africa/Ndjamena",
        "Africa/Niamey",
        "Africa/Nouakchott",
        "Africa/Ouagadougou",
        "Africa/Porto-Novo",
        "Africa/Sao_Tome",
        "Africa/Tripoli",
        "Africa/Tunis",
        "Africa/Windhoek",
        "America/Adak",
        "America/Anchorage",
        "America/Anguilla",
        "America/Antigua",
        "America/Araguaina",
        "America/Argentina/Buenos_Aires",
        "America/Argentina/Catamarca",
        "America/Argentina/Cordoba",
        "America/Argentina/Jujuy",
        "America/Argentina/La_Rioja",
        "America/Argentina/Mendoza",
        "America/Argentina/Rio_Gallegos",
        "America/Argentina/Salta",
        "America/Argentina/San_Juan",
        "America/Argentina/San_Luis",
        "America/Argentina/Tucuman",
        "America/Argentina/Ushuaia",
        "America/Aruba",
        "America/Asuncion",
        "America/Atikokan",
        "America/Bahia",
        "America/Bahia_Banderas",
        "America/Barbados",
        "America/Belem",
        "America/Belize",
        "America/Blanc-Sablon",
        "America/Boa_Vista",
        "America/Bogota",
        "America/Boise",
        "America/Cambridge_Bay",
        "America/Campo_Grande",
        "America/Cancun",
        "America/Caracas",
        "America/Cayenne",
        "America/Cayman",
        "America/Chicago",
        "America/Chihuahua",
        "America/Costa_Rica",
        "America/Creston",
        "America/Cuiaba",
        "America/Curacao",
        "America/Danmarkshavn",
        "America/Dawson",
        "America/Dawson_Creek",
        "America/Denver",
        "America/Detroit",
        "America/Dominica",
        "America/Edmonton",
        "America/Eirunepe",
        "America/El_Salvador",
        "America/Fort_Nelson",
        "America/Fortaleza",
        "America/Glace_Bay",
        "America/Goose_Bay",
        "America/Grand_Turk",
        "America/Grenada",
        "America/Guadeloupe",
        "America/Guatemala",
        "America/Guayaquil",
        "America/Guyana",
        "America/Halifax",
        "America/Havana",
        "America/Hermosillo",
        "America/Indiana/Indianapolis",
        "America/Indiana/Knox",
        "America/Indiana/Marengo",
        "America/Indiana/Petersburg",
        "America/Indiana/Tell_City",
        "America/Indiana/Vevay",
        "America/Indiana/Vincennes",
        "America/Indiana/Winamac",
        "America/Inuvik",
        "America/Iqaluit",
        "America/Jamaica",
        "America/Juneau",
        "America/Kentucky/Louisville",
        "America/Kentucky/Monticello",
        "America/Kralendijk",
        "America/La_Paz",
        "America/Lima",
        "America/Los_Angeles",
        "America/Lower_Princes",
        "America/Maceio",
        "America/Managua",
        "America/Manaus",
        "America/Marigot",
        "America/Martinique",
        "America/Matamoros",
        "America/Mazatlan",
        "America/Menominee",
        "America/Merida",
        "America/Metlakatla",
        "America/Mexico_City",
        "America/Miquelon",
        "America/Moncton",
        "America/Monterrey",
        "America/Montevideo",
        "America/Montserrat",
        "America/Nassau",
        "America/New_York",
        "America/Nipigon",
        "America/Nome",
        "America/Noronha",
        "America/North_Dakota/Beulah",
        "America/North_Dakota/Center",
        "America/North_Dakota/New_Salem",
        "America/Nuuk",
        "America/Ojinaga",
        "America/Panama",
        "America/Pangnirtung",
        "America/Paramaribo",
        "America/Phoenix",
        "America/Port-au-Prince",
        "America/Port_of_Spain",
        "America/Porto_Velho",
        "America/Puerto_Rico",
        "America/Punta_Arenas",
        "America/Rainy_River",
        "America/Rankin_Inlet",
        "America/Recife",
        "America/Regina",
        "America/Resolute",
        "America/Rio_Branco",
        "America/Santarem",
        "America/Santiago",
        "America/Santo_Domingo",
        "America/Sao_Paulo",
        "America/Scoresbysund",
        "America/Sitka",
        "America/St_Barthelemy",
        "America/St_Johns",
        "America/St_Kitts",
        "America/St_Lucia",
        "America/St_Thomas",
        "America/St_Vincent",
        "America/Swift_Current",
        "America/Tegucigalpa",
        "America/Thule",
        "America/Thunder_Bay",
        "America/Tijuana",
        "America/Toronto",
        "America/Tortola",
        "America/Vancouver",
        "America/Whitehorse",
        "America/Winnipeg",
        "America/Yakutat",
        "America/Yellowknife",
        "Antarctica/Casey",
        "Antarctica/Davis",
        "Antarctica/DumontDUrville",
        "Antarctica/Macquarie",
        "Antarctica/Mawson",
        "Antarctica/McMurdo",
        "Antarctica/Palmer",
        "Antarctica/Rothera",
        "Antarctica/Syowa",
        "Antarctica/Troll",
        "Antarctica/Vostok",
        "Arctic/Longyearbyen",
        "Asia/Aden",
        "Asia/Almaty",
        "Asia/Amman",
        "Asia/Anadyr",
        "Asia/Aqtau",
        "Asia/Aqtobe",
        "Asia/Ashgabat",
        "Asia/Atyrau",
        "Asia/Baghdad",
        "Asia/Bahrain",
        "Asia/Baku",
        "Asia/Bangkok",
        "Asia/Barnaul",
        "Asia/Beirut",
        "Asia/Bishkek",
        "Asia/Brunei",
        "Asia/Chita",
        "Asia/Choibalsan",
        "Asia/Colombo",
        "Asia/Damascus",
        "Asia/Dhaka",
        "Asia/Dili",
        "Asia/Dubai",
        "Asia/Dushanbe",
        "Asia/Famagusta",
        "Asia/Gaza",
        "Asia/Hebron",
        "Asia/Ho_Chi_Minh",
        "Asia/Hong_Kong",
        "Asia/Hovd",
        "Asia/Irkutsk",
        "Asia/Jakarta",
        "Asia/Jayapura",
        "Asia/Jerusalem",
        "Asia/Kabul",
        "Asia/Kamchatka",
        "Asia/Karachi",
        "Asia/Kathmandu",
        "Asia/Khandyga",
        "Asia/Kolkata",
        "Asia/Krasnoyarsk",
        "Asia/Kuala_Lumpur",
        "Asia/Kuching",
        "Asia/Kuwait",
        "Asia/Macau",
        "Asia/Magadan",
        "Asia/Makassar",
        "Asia/Manila",
        "Asia/Muscat",
        "Asia/Nicosia",
        "Asia/Novokuznetsk",
        "Asia/Novosibirsk",
        "Asia/Omsk",
        "Asia/Oral",
        "Asia/Phnom_Penh",
        "Asia/Pontianak",
        "Asia/Pyongyang",
        "Asia/Qatar",
        "Asia/Qostanay",
        "Asia/Qyzylorda",
        "Asia/Riyadh",
        "Asia/Sakhalin",
        "Asia/Samarkand",
        "Asia/Seoul",
        "Asia/Shanghai",
        "Asia/Singapore",
        "Asia/Srednekolymsk",
        "Asia/Taipei",
        "Asia/Tashkent",
        "Asia/Tbilisi",
        "Asia/Tehran",
        "Asia/Thimphu",
        "Asia/Tokyo",
        "Asia/Tomsk",
        "Asia/Ulaanbaatar",
        "Asia/Urumqi",
        "Asia/Ust-Nera",
        "Asia/Vientiane",
        "Asia/Vladivostok",
        "Asia/Yakutsk",
        "Asia/Yangon",
        "Asia/Yekaterinburg",
        "Asia/Yerevan",
        "Atlantic/Azores",
        "Atlantic/Bermuda",
        "Atlantic/Canary",
        "Atlantic/Cape_Verde",
        "Atlantic/Faroe",
        "Atlantic/Madeira",
        "Atlantic/Reykjavik",
        "Atlantic/South_Georgia",
        "Atlantic/St_Helena",
        "Atlantic/Stanley",
        "Australia/Adelaide",
        "Australia/Brisbane",
        "Australia/Broken_Hill",
        "Australia/Darwin",
        "Australia/Eucla",
        "Australia/Hobart",
        "Australia/Lindeman",
        "Australia/Lord_Howe",
        "Australia/Melbourne",
        "Australia/Perth",
        "Australia/Sydney",
        "Europe/Amsterdam",
        "Europe/Andorra",
        "Europe/Astrakhan",
        "Europe/Athens",
        "Europe/Belgrade",
        "Europe/Berlin",
        "Europe/Bratislava",
        "Europe/Brussels",
        "Europe/Bucharest",
        "Europe/Budapest",
        "Europe/Chisinau",
        "Europe/Copenhagen",
        "Europe/Dublin",
        "Europe/Gibraltar",
        "Europe/Guernsey",
        "Europe/Helsinki",
        "Europe/Isle_of_Man",
        "Europe/Istanbul",
        "Europe/Jersey",
        "Europe/Kaliningrad",
        "Europe/Kiev",
        "Europe/Kirov",
        "Europe/Lisbon",
        "Europe/Ljubljana",
        "Europe/London",
        "Europe/Luxembourg",
        "Europe/Madrid",
        "Europe/Malta",
        "Europe/Mariehamn",
        "Europe/Minsk",
        "Europe/Monaco",
        "Europe/Moscow",
        "Europe/Oslo",
        "Europe/Paris",
        "Europe/Podgorica",
        "Europe/Prague",
        "Europe/Riga",
        "Europe/Rome",
        "Europe/Samara",
        "Europe/San_Marino",
        "Europe/Sarajevo",
        "Europe/Saratov",
        "Europe/Simferopol",
        "Europe/Skopje",
        "Europe/Sofia",
        "Europe/Stockholm",
        "Europe/Tallinn",
        "Europe/Tirane",
        "Europe/Ulyanovsk",
        "Europe/Uzhgorod",
        "Europe/Vaduz",
        "Europe/Vatican",
        "Europe/Vienna",
        "Europe/Vilnius",
        "Europe/Volgograd",
        "Europe/Warsaw",
        "Europe/Zagreb",
        "Europe/Zaporozhye",
        "Europe/Zurich",
        "Indian/Antananarivo",
        "Indian/Chagos",
        "Indian/Christmas",
        "Indian/Cocos",
        "Indian/Comoro",
        "Indian/Kerguelen",
        "Indian/Mahe",
        "Indian/Maldives",
        "Indian/Mauritius",
        "Indian/Mayotte",
        "Indian/Reunion",
        "Pacific/Apia",
        "Pacific/Auckland",
        "Pacific/Bougainville",
        "Pacific/Chatham",
        "Pacific/Chuuk",
        "Pacific/Easter",
        "Pacific/Efate",
        "Pacific/Enderbury",
        "Pacific/Fakaofo",
        "Pacific/Fiji",
        "Pacific/Funafuti",
        "Pacific/Galapagos",
        "Pacific/Gambier",
        "Pacific/Guadalcanal",
        "Pacific/Guam",
        "Pacific/Honolulu",
        "Pacific/Kiritimati",
        "Pacific/Kosrae",
        "Pacific/Kwajalein",
        "Pacific/Majuro",
        "Pacific/Marquesas",
        "Pacific/Midway",
        "Pacific/Nauru",
        "Pacific/Niue",
        "Pacific/Norfolk",
        "Pacific/Noumea",
        "Pacific/Pago_Pago",
        "Pacific/Palau",
        "Pacific/Pitcairn",
        "Pacific/Pohnpei",
        "Pacific/Port_Moresby",
        "Pacific/Rarotonga",
        "Pacific/Saipan",
        "Pacific/Tahiti",
        "Pacific/Tarawa",
        "Pacific/Tongatapu",
        "Pacific/Wake",
        "Pacific/Wallis",
        "UTC",
}

// IsValidTimezone checks if the given timezone is valid
func IsValidTimezone(timezone string) bool <span class="cov8" title="1">{
        for _, tz := range Timezones </span><span class="cov8" title="1">{
                if tz == timezone </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package domain

import (
        "context"
        "time"
)

// User represents a user in the system
type User struct {
        ID        string    `json:"id" db:"id"`
        Email     string    `json:"email" db:"email"`
        Name      string    `json:"name,omitempty" db:"name"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// Session represents a user session
type Session struct {
        ID               string    `json:"id" db:"id"`
        UserID           string    `json:"user_id" db:"user_id"`
        ExpiresAt        time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt        time.Time `json:"created_at" db:"created_at"`
        MagicCode        string    `json:"magic_code,omitempty" db:"magic_code"`
        MagicCodeExpires time.Time `json:"magic_code_expires,omitempty" db:"magic_code_expires_at"`
}

type SignInInput struct {
        Email string `json:"email"`
}

type VerifyCodeInput struct {
        Email string `json:"email"`
        Code  string `json:"code"`
}

type AuthResponse struct {
        Token     string    `json:"token"`
        User      User      `json:"user"`
        ExpiresAt time.Time `json:"expires_at"`
}

// UserServiceInterface defines the interface for user operations
type UserServiceInterface interface {
        SignIn(ctx context.Context, input SignInInput) (string, error)
        VerifyCode(ctx context.Context, input VerifyCodeInput) (*AuthResponse, error)
        VerifyUserSession(ctx context.Context, userID string, sessionID string) (*User, error)
        GetUserByID(ctx context.Context, userID string) (*User, error)
        GetUserByEmail(ctx context.Context, email string) (*User, error)
}

type UserRepository interface {
        // CreateUser creates a new user in the database
        CreateUser(ctx context.Context, user *User) error

        // GetUserByEmail retrieves a user by their email address
        GetUserByEmail(ctx context.Context, email string) (*User, error)

        // GetUserByID retrieves a user by their ID
        GetUserByID(ctx context.Context, id string) (*User, error)

        // CreateSession creates a new session for a user
        CreateSession(ctx context.Context, session *Session) error

        // GetSessionByID retrieves a session by its ID
        GetSessionByID(ctx context.Context, id string) (*Session, error)

        // GetSessionsByUserID retrieves all sessions for a user
        GetSessionsByUserID(ctx context.Context, userID string) ([]*Session, error)

        // UpdateSession updates an existing session
        UpdateSession(ctx context.Context, session *Session) error

        // DeleteSession deletes a session by its ID
        DeleteSession(ctx context.Context, id string) error
}

// ErrUserNotFound is returned when a user is not found
type ErrUserNotFound struct {
        Message string
}

func (e *ErrUserNotFound) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// ErrSessionNotFound is returned when a session is not found
type ErrSessionNotFound struct {
        Message string
}

func (e *ErrSessionNotFound) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package domain

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "github.com/asaskevich/govalidator"
)

//go:generate mockgen -destination mocks/mock_workspace_repository.go -package mocks github.com/Notifuse/notifuse/internal/domain WorkspaceRepository
//go:generate mockgen -destination mocks/mock_workspace_service.go -package mocks github.com/Notifuse/notifuse/internal/domain WorkspaceServiceInterface

// WorkspaceSettings contains configurable workspace settings
type WorkspaceSettings struct {
        WebsiteURL string `json:"website_url,omitempty" valid:"url,optional"`
        LogoURL    string `json:"logo_url,omitempty" valid:"url,optional"`
        CoverURL   string `json:"cover_url,omitempty" valid:"url,optional"`
        Timezone   string `json:"timezone" valid:"required,timezone"`
}

type Workspace struct {
        ID        string            `json:"id" valid:"required,alphanum,stringlength(1|20)"`
        Name      string            `json:"name" valid:"required,stringlength(1|255)"`
        Settings  WorkspaceSettings `json:"settings"`
        CreatedAt time.Time         `json:"created_at"`
        UpdatedAt time.Time         `json:"updated_at"`
}

// Validate performs validation on the workspace fields
func (w *Workspace) Validate() error <span class="cov8" title="1">{
        // Register custom validators
        govalidator.TagMap["timezone"] = govalidator.Validator(func(str string) bool </span><span class="cov8" title="1">{
                return IsValidTimezone(str)
        }</span>)

        // First validate the workspace itself
        <span class="cov8" title="1">if _, err := govalidator.ValidateStruct(w); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid workspace: %w", err)
        }</span>

        // Then validate the settings
        <span class="cov8" title="1">if _, err := govalidator.ValidateStruct(&amp;w.Settings); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid workspace settings: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// For database scanning
type dbWorkspace struct {
        ID        string
        Name      string
        Settings  []byte
        CreatedAt time.Time
        UpdatedAt time.Time
}

// ScanWorkspace scans a workspace from the database
func ScanWorkspace(scanner interface {
        Scan(dest ...interface{}) error
}) (*Workspace, error) <span class="cov8" title="1">{
        var dbw dbWorkspace
        if err := scanner.Scan(
                &amp;dbw.ID,
                &amp;dbw.Name,
                &amp;dbw.Settings,
                &amp;dbw.CreatedAt,
                &amp;dbw.UpdatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">w := &amp;Workspace{
                ID:        dbw.ID,
                Name:      dbw.Name,
                CreatedAt: dbw.CreatedAt,
                UpdatedAt: dbw.UpdatedAt,
        }

        if err := json.Unmarshal(dbw.Settings, &amp;w.Settings); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal settings: %w", err)
        }</span>

        <span class="cov8" title="1">return w, nil</span>
}

// UserWorkspace represents the relationship between a user and a workspace
type UserWorkspace struct {
        UserID      string    `json:"user_id" db:"user_id"`
        WorkspaceID string    `json:"workspace_id" db:"workspace_id"`
        Role        string    `json:"role" db:"role" valid:"required,in(owner|member)"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

// UserWorkspaceWithEmail extends UserWorkspace to include user email
type UserWorkspaceWithEmail struct {
        UserWorkspace
        Email string `json:"email" db:"email"`
}

// Validate performs validation on the user workspace fields
func (uw *UserWorkspace) Validate() error <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(uw); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid user workspace: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// WorkspaceInvitation represents an invitation to a workspace
type WorkspaceInvitation struct {
        ID          string    `json:"id"`
        WorkspaceID string    `json:"workspace_id"`
        InviterID   string    `json:"inviter_id"`
        Email       string    `json:"email"`
        ExpiresAt   time.Time `json:"expires_at"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

type WorkspaceRepository interface {
        Create(ctx context.Context, workspace *Workspace) error
        GetByID(ctx context.Context, id string) (*Workspace, error)
        List(ctx context.Context) ([]*Workspace, error)
        Update(ctx context.Context, workspace *Workspace) error
        Delete(ctx context.Context, id string) error

        // User workspace management
        AddUserToWorkspace(ctx context.Context, userWorkspace *UserWorkspace) error
        RemoveUserFromWorkspace(ctx context.Context, userID string, workspaceID string) error
        GetUserWorkspaces(ctx context.Context, userID string) ([]*UserWorkspace, error)
        GetWorkspaceUsersWithEmail(ctx context.Context, workspaceID string) ([]*UserWorkspaceWithEmail, error)
        GetUserWorkspace(ctx context.Context, userID string, workspaceID string) (*UserWorkspace, error)

        // Workspace invitation management
        CreateInvitation(ctx context.Context, invitation *WorkspaceInvitation) error
        GetInvitationByID(ctx context.Context, id string) (*WorkspaceInvitation, error)
        GetInvitationByEmail(ctx context.Context, workspaceID, email string) (*WorkspaceInvitation, error)
        IsUserWorkspaceMember(ctx context.Context, userID, workspaceID string) (bool, error)

        // Database management
        GetConnection(ctx context.Context, workspaceID string) (*sql.DB, error)
        CreateDatabase(ctx context.Context, workspaceID string) error
        DeleteDatabase(ctx context.Context, workspaceID string) error
}

// ErrUnauthorized is returned when a user is not authorized to perform an action
type ErrUnauthorized struct {
        Message string
}

func (e *ErrUnauthorized) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// WorkspaceServiceInterface defines the interface for workspace operations
type WorkspaceServiceInterface interface {
        CreateWorkspace(ctx context.Context, id, name, websiteURL, logoURL, coverURL, timezone string) (*Workspace, error)
        GetWorkspace(ctx context.Context, id string) (*Workspace, error)
        ListWorkspaces(ctx context.Context) ([]*Workspace, error)
        UpdateWorkspace(ctx context.Context, id, name, websiteURL, logoURL, coverURL, timezone string) (*Workspace, error)
        DeleteWorkspace(ctx context.Context, id string) error
        GetWorkspaceMembersWithEmail(ctx context.Context, id string) ([]*UserWorkspaceWithEmail, error)
        InviteMember(ctx context.Context, workspaceID, email string) (*WorkspaceInvitation, string, error)
        AddUserToWorkspace(ctx context.Context, workspaceID string, userID string, role string) error
        RemoveUserFromWorkspace(ctx context.Context, workspaceID string, userID string) error
        TransferOwnership(ctx context.Context, workspaceID string, newOwnerID string, currentOwnerID string) error
}

// Request/Response types
type CreateWorkspaceRequest struct {
        ID       string                `json:"id" valid:"required,alphanum,stringlength(1|20)"`
        Name     string                `json:"name" valid:"required,stringlength(1|32)"`
        Settings WorkspaceSettingsData `json:"settings" valid:"required"`
}

func (r *CreateWorkspaceRequest) Validate() error <span class="cov8" title="1">{
        // Register custom validators
        govalidator.TagMap["timezone"] = govalidator.Validator(func(str string) bool </span><span class="cov8" title="1">{
                return IsValidTimezone(str)
        }</span>)

        <span class="cov8" title="1">if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid create workspace request: %w", err)
        }</span>

        // Also validate the settings
        <span class="cov8" title="1">if _, err := govalidator.ValidateStruct(&amp;r.Settings); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid create workspace request: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type WorkspaceSettingsData struct {
        Name       string `json:"name" valid:"required,stringlength(1|32)"`
        WebsiteURL string `json:"website_url" valid:"url,optional"`
        LogoURL    string `json:"logo_url" valid:"url,optional"`
        CoverURL   string `json:"cover_url" valid:"url,optional"`
        Timezone   string `json:"timezone" valid:"required,timezone"`
}

type GetWorkspaceRequest struct {
        ID string `json:"id"`
}

type UpdateWorkspaceRequest struct {
        ID         string `json:"id" valid:"required,alphanum,stringlength(1|20)"`
        Name       string `json:"name" valid:"required,stringlength(1|32)"`
        WebsiteURL string `json:"website_url" valid:"url,optional"`
        LogoURL    string `json:"logo_url" valid:"url,optional"`
        CoverURL   string `json:"cover_url" valid:"url,optional"`
        Timezone   string `json:"timezone" valid:"required,timezone"`
}

func (r *UpdateWorkspaceRequest) Validate() error <span class="cov8" title="1">{
        // Register custom validators
        govalidator.TagMap["timezone"] = govalidator.Validator(func(str string) bool </span><span class="cov8" title="1">{
                return IsValidTimezone(str)
        }</span>)

        <span class="cov8" title="1">if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid update workspace request: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type DeleteWorkspaceRequest struct {
        ID string `json:"id" valid:"required,alphanum,stringlength(1|20)"`
}

func (r *DeleteWorkspaceRequest) Validate() error <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid delete workspace request: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type InviteMemberRequest struct {
        WorkspaceID string `json:"workspace_id" valid:"required,alphanum,stringlength(1|20)"`
        Email       string `json:"email" valid:"required,email"`
}

func (r *InviteMemberRequest) Validate() error <span class="cov8" title="1">{
        if _, err := govalidator.ValidateStruct(r); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid invite member request: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
